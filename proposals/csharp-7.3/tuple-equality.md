---
ms.openlocfilehash: f238a711e710bbac7f5b7400fa938bd85dec00c6
ms.sourcegitcommit: 5278336b61519956240a6f7d83bcb4322019e032
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/10/2020
ms.locfileid: "79485254"
---
# <a name="support-for--and--on-tuple-types"></a><span data-ttu-id="badb1-101">Tanımlama grubu türlerinde = = ve! = desteği</span><span class="sxs-lookup"><span data-stu-id="badb1-101">Support for == and != on tuple types</span></span>

<span data-ttu-id="badb1-102">`t1 == t2`, `t1` ve `t2` aynı kardinalite türü veya null yapılabilir demet türleri olduğu ve bunları kabaca `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` olarak değerlendirmek için (`var temp1 = t1; var temp2 = t2;`varsayıldığında) ifadeye izin verin.</span><span class="sxs-lookup"><span data-stu-id="badb1-102">Allow expressions `t1 == t2` where `t1` and `t2` are tuple or nullable tuple types of same cardinality, and evaluate them roughly as `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` (assuming `var temp1 = t1; var temp2 = t2;`).</span></span>

<span data-ttu-id="badb1-103">Bunun tersine, `t1 != t2` izin verecek ve `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`olarak değerlendirmelidir.</span><span class="sxs-lookup"><span data-stu-id="badb1-103">Conversely it would allow `t1 != t2` and evaluate it as `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`.</span></span>

<span data-ttu-id="badb1-104">Null yapılabilir durumda, `temp1.HasValue` ve `temp2.HasValue` için ek denetimler kullanılır.</span><span class="sxs-lookup"><span data-stu-id="badb1-104">In the nullable case, additional checks for `temp1.HasValue` and `temp2.HasValue` are used.</span></span> <span data-ttu-id="badb1-105">Örneğin, `nullableT1 == nullableT2` `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="badb1-105">For instance, `nullableT1 == nullableT2` evaluates as `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`.</span></span>

<span data-ttu-id="badb1-106">Öğe odaklı bir karşılaştırma bool olmayan bir sonuç döndürdüğünde (örneğin, bool olmayan kullanıcı tanımlı bir `operator ==` veya `operator !=` kullanıldığında ya da dinamik bir karşılaştırmayla), bu sonuç, `operator false` almak için `operator true` veya `bool`üzerinden `bool` veya çalıştırılacak şekilde değişir.</span><span class="sxs-lookup"><span data-stu-id="badb1-106">When an element-wise comparison returns a non-bool result (for instance, when a non-bool user-defined `operator ==` or `operator !=` is used, or in a dynamic comparison), then that result will be either converted to `bool` or run through `operator true` or `operator false` to get a `bool`.</span></span> <span data-ttu-id="badb1-107">Demet karşılaştırma her zaman `bool`döndürür.</span><span class="sxs-lookup"><span data-stu-id="badb1-107">The tuple comparison always ends up returning a `bool`.</span></span>

<span data-ttu-id="badb1-108">C# 7,2 itibariyle, Kullanıcı tanımlı bir `operator==`olmadıkça bu tür kod bir hata (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`) oluşturur.</span><span class="sxs-lookup"><span data-stu-id="badb1-108">As of C# 7.2, such code produces an error (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`), unless there is a user-defined `operator==`.</span></span>

## <a name="details"></a><span data-ttu-id="badb1-109">Ayrıntılar</span><span class="sxs-lookup"><span data-stu-id="badb1-109">Details</span></span>

<span data-ttu-id="badb1-110">`==` (veya `!=`) işlecini bağlarken, var olan kurallar: (1) dinamik durum, (2) aşırı yükleme çözünürlüğü ve (3) başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="badb1-110">When binding the `==` (or `!=`) operator, the existing rules are: (1) dynamic case, (2) overload resolution, and (3) fail.</span></span>
<span data-ttu-id="badb1-111">Bu teklif, (1) ve (2) arasında bir tanımlama grubu durumu ekler: bir karşılaştırma işlecinin her iki işleneni de tanımlama grubu ise (demet türlerine sahip veya demet sabit değerlerinde) ve eşleşen kardinalite varsa, karşılaştırma öğe temelinde gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="badb1-111">This proposal adds a tuple case between (1) and (2): if both operands of a comparison operator are tuples (have tuple types or are tuple literals) and have matching cardinality, then the comparison is performed element-wise.</span></span> <span data-ttu-id="badb1-112">Bu tanımlama grubu eşitliği de null yapılabilir diziler üzerine yükseltilmemiş.</span><span class="sxs-lookup"><span data-stu-id="badb1-112">This tuple equality is also lifted onto nullable tuples.</span></span>

<span data-ttu-id="badb1-113">Her iki işlenen de (ve kayıt kümesi değişmez değerleri, öğeleri) soldan sağa doğru sırayla değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="badb1-113">Both operands (and, in the case of tuple literals, their elements) are evaluated in order from left to right.</span></span> <span data-ttu-id="badb1-114">Her öğe çifti, işleci `==` (veya `!=`) yinelemeli olarak bağlamak için işlenen olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="badb1-114">Each pair of elements is then used as operands to bind the operator `==` (or `!=`), recursively.</span></span> <span data-ttu-id="badb1-115">Derleme zamanı türü olan herhangi bir öğe `dynamic` hataya neden olur.</span><span class="sxs-lookup"><span data-stu-id="badb1-115">Any elements with compile-time type `dynamic` cause an error.</span></span> <span data-ttu-id="badb1-116">Bu öğe temelinde karşılaştırmaların sonuçları, bir koşullu ve (veya veya) işleçler zincirinde işlenen olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="badb1-116">The results of those element-wise comparisons are used as operands in a chain of conditional AND (or OR) operators.</span></span>

<span data-ttu-id="badb1-117">Örneğin, `(int, (int, int)) t1, t2;`bağlamında `t1 == (1, (2, 3))` `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp2.Item2.Item2 == temp2.Item2.Item2`olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="badb1-117">For instance, in the context of `(int, (int, int)) t1, t2;`, `t1 == (1, (2, 3))` would evaluate as `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp2.Item2.Item2 == temp2.Item2.Item2`.</span></span>

<span data-ttu-id="badb1-118">Bir tanımlama grubu sabit değeri işlenen olarak kullanıldığında (her iki tarafta), işleç `==` (veya `!=`) öğe temelinde bir kez eklendiğinde tanıtılan öğe temelinde dönüştürmeler tarafından oluşturulan dönüştürülmüş bir tanımlama grubu türü alır.</span><span class="sxs-lookup"><span data-stu-id="badb1-118">When a tuple literal is used as operand (on either side), it receives a converted tuple type formed by the element-wise conversions which are introduced when binding the operator `==` (or `!=`) element-wise.</span></span> 

<span data-ttu-id="badb1-119">Örneğin, `(1L, 2, "hello") == (1, 2L, null)`, her iki demet için de dönüştürülmüş tür `(long, long, string)` ve ikinci değişmez değer doğal bir türe sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="badb1-119">For instance, in `(1L, 2, "hello") == (1, 2L, null)`, the converted type for both tuple literals is `(long, long, string)` and the second literal has no natural type.</span></span>


### <a name="deconstruction-and-conversions-to-tuple"></a><span data-ttu-id="badb1-120">Kayıt düzeni için ayrıştırma ve dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="badb1-120">Deconstruction and conversions to tuple</span></span>
<span data-ttu-id="badb1-121">`(a, b) == x`, `x` iki öğe içinde oluşturabileceği ve bir rol oynamıyor.</span><span class="sxs-lookup"><span data-stu-id="badb1-121">In `(a, b) == x`, the fact that `x` can deconstruct into two elements does not play a role.</span></span> <span data-ttu-id="badb1-122">Bu, gelecekte `x == y` (basit bir karşılaştırma veya öğe temelinde karşılaştırma) ve bu durum, ne kardinalite kullanılması gerektiğini belirten sorular çalıp.</span><span class="sxs-lookup"><span data-stu-id="badb1-122">That could conceivably be in a future proposal, although it would raise questions about `x == y` (is this a simple comparison or an element-wise comparison, and if so using what cardinality?).</span></span>
<span data-ttu-id="badb1-123">Benzer şekilde, kayıt düzeni dönüştürmeleri de rol içermez.</span><span class="sxs-lookup"><span data-stu-id="badb1-123">Similarly, conversions to tuple play no role.</span></span>

### <a name="tuple-element-names"></a><span data-ttu-id="badb1-124">Demet öğesi adları</span><span class="sxs-lookup"><span data-stu-id="badb1-124">Tuple element names</span></span>

<span data-ttu-id="badb1-125">Bir tanımlama grubu değişmez değeri dönüştürülürken, sabit değerinde açık bir demet öğesi adı sağlandığında, ancak hedef demet öğe adıyla eşleşmez.</span><span class="sxs-lookup"><span data-stu-id="badb1-125">When converting a tuple literal, we warn when an explicit tuple element name was provided in the literal, but it doesn't match the target tuple element name.</span></span>
<span data-ttu-id="badb1-126">Kayıt düzeni karşılaştırmalarında aynı kuralı kullanıyoruz, bu sayede `t == (c, d: 0)``d` `(int a, int b) t` olduğunu varsayıyoruz.</span><span class="sxs-lookup"><span data-stu-id="badb1-126">We use the same rule in tuple comparison, so that assuming `(int a, int b) t` we warn on `d` in `t == (c, d: 0)`.</span></span>

### <a name="non-bool-element-wise-comparison-results"></a><span data-ttu-id="badb1-127">Bool olmayan öğe temelinde karşılaştırma sonuçları</span><span class="sxs-lookup"><span data-stu-id="badb1-127">Non-bool element-wise comparison results</span></span>

<span data-ttu-id="badb1-128">Öğe odaklı bir karşılaştırma, kayıt düzeni eşitliğine dinamik ise, işleç `false` dinamik bir şekilde çağırdık ve bir `bool` almak ve daha fazla öğe temelinde karşılaştırmayla devam etmek için Negate kullanırız.</span><span class="sxs-lookup"><span data-stu-id="badb1-128">If an element-wise comparison is dynamic in a tuple equality, we use a dynamic invocation of the operator `false` and negate that to get a `bool` and continue with further element-wise comparisons.</span></span> 

<span data-ttu-id="badb1-129">Öğe temelinde karşılaştırma, bir tanımlama grubu eşitliğine başka bir bool olmayan tür döndürürse iki durum vardır:</span><span class="sxs-lookup"><span data-stu-id="badb1-129">If an element-wise comparison returns some other non-bool type in a tuple equality, there are two cases:</span></span>
- <span data-ttu-id="badb1-130">bool olmayan tür `bool`olarak dönüştürürse, bu dönüştürme uygulanır,</span><span class="sxs-lookup"><span data-stu-id="badb1-130">if the non-bool type converts to `bool`, we apply that conversion,</span></span>
- <span data-ttu-id="badb1-131">Böyle bir dönüştürme yoksa, ancak türün bir işleç `false`varsa, bunu kullanacağız ve sonucu kullanacaksınız.</span><span class="sxs-lookup"><span data-stu-id="badb1-131">if there is no such conversion, but the type has an operator `false`, we'll use that and negate the result.</span></span>

<span data-ttu-id="badb1-132">Bir dizi eşitsizlik içinde, işleç `false`yerine işleci `true` (olumsuzlama olmadan) kullanacağımız için aynı kurallar geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="badb1-132">In a tuple inequality, the same rules apply except that we'll use the operator `true` (without negation) instead of the operator `false`.</span></span>

<span data-ttu-id="badb1-133">Bu kurallar, `if` bildiriminde bool olmayan bir tür ve diğer mevcut bağlamların kullanılmasına benzer kurallara benzerdir.</span><span class="sxs-lookup"><span data-stu-id="badb1-133">Those rules are similar to the rules involved for using a non-bool type in an `if` statement and some other existing contexts.</span></span>

## <a name="evaluation-order-and-special-cases"></a><span data-ttu-id="badb1-134">Değerlendirme siparişi ve özel durumlar</span><span class="sxs-lookup"><span data-stu-id="badb1-134">Evaluation order and special cases</span></span>
<span data-ttu-id="badb1-135">Sol taraftaki değer önce, sonra sağ taraftaki değer ' i, sonra da soldan sağa karşılaştırmaları (dönüşümler dahil olmak üzere ve koşullu ve/veya operatörler için var olan kurallara göre erken çıkış ile) değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="badb1-135">The left-hand-side value is evaluated first, then the right-hand-side value, then the element-wise comparisons from left to right (including conversions, and with early exit based on existing rules for conditional AND/OR operators).</span></span>

<span data-ttu-id="badb1-136">Örneğin, tür `B` türüne `A` bir dönüştürme varsa ve bir yöntem `(A, A) GetTuple()`, `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` değerlendirmesi yapılır:</span><span class="sxs-lookup"><span data-stu-id="badb1-136">For instance, if there is a conversion from type `A` to type `B` and a method `(A, A) GetTuple()`, evaluating `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` means:</span></span>
- `new A(1)`
- `new B(2)`
- `new B(3)`
- `new B(4)`
- `GetTuple()`
- <span data-ttu-id="badb1-137">sonra öğe temelinde dönüştürmeler ve karşılaştırmalar ve koşullu mantık değerlendirilir (`new A(1)` `B`türüne dönüştürüp `new B(4)`, vb. ile karşılaştırın).</span><span class="sxs-lookup"><span data-stu-id="badb1-137">then the element-wise conversions and comparisons and conditional logic is evaluated (convert `new A(1)` to type `B`, then compare it with `new B(4)`, and so on).</span></span>

### <a name="comparing-null-to-null"></a><span data-ttu-id="badb1-138">`null` `null` karşılaştırma</span><span class="sxs-lookup"><span data-stu-id="badb1-138">Comparing `null` to `null`</span></span>

<span data-ttu-id="badb1-139">Bu, normal karşılaştırmalardan, kayıt düzeni karşılaştırmalarının üzerinde yer alan özel bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="badb1-139">This is a special case from regular comparisons, that carries over to tuple comparisons.</span></span> <span data-ttu-id="badb1-140">`null == null` karşılaştırmaya izin verilir ve `null` değişmez değerleri herhangi bir tür almaz.</span><span class="sxs-lookup"><span data-stu-id="badb1-140">The `null == null` comparison is allowed, and the `null` literals do not get any type.</span></span>
<span data-ttu-id="badb1-141">Tanımlama grubu eşitliğine bu, `(0, null) == (0, null)` izin verilen ve `null` ve demet sabit değerlerinin bir tür alması anlamına da gelir.</span><span class="sxs-lookup"><span data-stu-id="badb1-141">In tuple equality, this means, `(0, null) == (0, null)` is also allowed and the `null` and tuple literals don't get a type either.</span></span>

### <a name="comparing-a-nullable-struct-to-null-without-operator"></a><span data-ttu-id="badb1-142">Null yapılabilir bir yapıyı `operator==` olmadan `null` karşılaştırma</span><span class="sxs-lookup"><span data-stu-id="badb1-142">Comparing a nullable struct to `null` without `operator==`</span></span>

<span data-ttu-id="badb1-143">Bu, normal karşılaştırmalardan, kayıt düzeni karşılaştırmalarının üzerinde yer alan başka bir özel durumdur.</span><span class="sxs-lookup"><span data-stu-id="badb1-143">This is another special case from regular comparisons, that carries over to tuple comparisons.</span></span>
<span data-ttu-id="badb1-144">`operator==`olmayan bir `struct S` varsa `(S?)x == null` karşılaştırmaya izin verilir ve `((S?).x).HasValue`olarak yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="badb1-144">If you have a `struct S` without `operator==`, the `(S?)x == null` comparison is allowed, and it is interpreted as `((S?).x).HasValue`.</span></span>
<span data-ttu-id="badb1-145">Kayıt düzeni eşitliğine aynı kural uygulandı, bu nedenle `(0, (S?)x) == (0, null)` izin verilir.</span><span class="sxs-lookup"><span data-stu-id="badb1-145">In tuple equality, the same rule is applied, so `(0, (S?)x) == (0, null)` is allowed.</span></span>

## <a name="compatibility"></a><span data-ttu-id="badb1-146">Uyumluluk</span><span class="sxs-lookup"><span data-stu-id="badb1-146">Compatibility</span></span>

<span data-ttu-id="badb1-147">Biri karşılaştırma işlecinin uygulamasıyla kendi `ValueTuple` türlerini yazdıysa, daha önce aşırı yükleme çözümlemesi tarafından çekilmiş olur.</span><span class="sxs-lookup"><span data-stu-id="badb1-147">If someone wrote their own `ValueTuple` types with  an implementation of the comparison operator, it would have previously been picked up by overload resolution.</span></span> <span data-ttu-id="badb1-148">Ancak yeni demet durumu aşırı yükleme çözümlenmesinden önce geldiğinden, bu durumu Kullanıcı tanımlı karşılaştırmaya güvenmek yerine demet karşılaştırmayla işleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="badb1-148">But since the new tuple case comes before overload resolution, we would handle this case with tuple comparison instead of relying on the user-defined comparison.</span></span>

----

<span data-ttu-id="badb1-149">[İlişkisel ve tür testi işleçleri](../../spec/expressions.md#relational-and-type-testing-operators) [#190](https://github.com/dotnet/csharplang/issues/190) ile ilgilidir</span><span class="sxs-lookup"><span data-stu-id="badb1-149">Relates to [relational and type testing operators](../../spec/expressions.md#relational-and-type-testing-operators) Relates to [#190](https://github.com/dotnet/csharplang/issues/190)</span></span>
