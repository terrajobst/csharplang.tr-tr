---
ms.openlocfilehash: 4d6d28a3127bc701867afe157aa5496377a06f69
ms.sourcegitcommit: 63d276488c9770a565fd787020783ffc1d2af9d6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/05/2019
ms.locfileid: "74868010"
---
# <a name="conversions"></a><span data-ttu-id="f7b28-101">Dönüşümler</span><span class="sxs-lookup"><span data-stu-id="f7b28-101">Conversions</span></span>

<span data-ttu-id="f7b28-102">Bir ***dönüştürme*** , bir ifadenin belirli bir türde olması halinde değerlendirilmesine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="f7b28-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="f7b28-103">Bir dönüştürme, belirli bir türün ifadesinin farklı bir tür varmış gibi işlenmesine neden olabilir veya tür olmayan bir ifadenin tür almasını sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="f7b28-104">Dönüştürmeler ***örtük*** veya ***Açık***olabilir ve bu, açık bir dönüştürmenin gerekli olup olmadığını belirler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="f7b28-105">Örneğin, `int` türünden `long` türüne dönüştürme örtük olur, bu nedenle `int` türündeki ifadeler örtük olarak tür `long`olarak kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="f7b28-106">`long` türünden `int`türüne ters dönüştürme açık olduğundan açık bir dönüştürme gerekir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="f7b28-107">Bazı dönüşümler dil tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="f7b28-108">Programlar, kendi dönüştürmelerini ([Kullanıcı tanımlı dönüştürmeler](conversions.md#user-defined-conversions)) de tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="f7b28-109">Örtük dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-109">Implicit conversions</span></span>

<span data-ttu-id="f7b28-110">Aşağıdaki dönüşümler örtük dönüştürmeler olarak sınıflandırılmaktadır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="f7b28-111">Kimlik dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-111">Identity conversions</span></span>
*  <span data-ttu-id="f7b28-112">Örtük Sayısal dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="f7b28-113">Örtük numaralandırma dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-113">Implicit enumeration conversions</span></span>
*  <span data-ttu-id="f7b28-114">Örtülü olarak bulunan dize dönüşümleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-114">Implicit interpolated string conversions</span></span>
*  <span data-ttu-id="f7b28-115">Örtük null yapılabilir dönüşümler</span><span class="sxs-lookup"><span data-stu-id="f7b28-115">Implicit nullable conversions</span></span>
*  <span data-ttu-id="f7b28-116">Null değişmez değer dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-116">Null literal conversions</span></span>
*  <span data-ttu-id="f7b28-117">Örtük başvuru dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-117">Implicit reference conversions</span></span>
*  <span data-ttu-id="f7b28-118">Paketleme dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-118">Boxing conversions</span></span>
*  <span data-ttu-id="f7b28-119">Örtük dinamik dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-119">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="f7b28-120">Örtük sabit ifade dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-120">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="f7b28-121">Kullanıcı tanımlı örtük dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-121">User-defined implicit conversions</span></span>
*  <span data-ttu-id="f7b28-122">Anonim işlev dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-122">Anonymous function conversions</span></span>
*  <span data-ttu-id="f7b28-123">Yöntem grubu dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-123">Method group conversions</span></span>

<span data-ttu-id="f7b28-124">Örtük dönüştürmeler işlev üyesi etkinleştirmeleri ([dinamik aşırı yükleme çözümünün derleme zamanı denetimi](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), atama Ifadeleri (atama işleçleri[) ve](expressions.md#cast-expressions)atamalar ([atama işleçleri](expressions.md#assignment-operators)) dahil olmak üzere çeşitli durumlarda gerçekleşebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-124">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="f7b28-125">Önceden tanımlanmış örtük dönüştürmeler her zaman başarılı olur ve hiçbir zaman özel durum oluşturulmasına neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="f7b28-125">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="f7b28-126">Doğru şekilde tasarlanan Kullanıcı tanımlı örtük dönüştürmeler bu özellikleri de göstermelidir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-126">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="f7b28-127">Dönüştürme amaçları doğrultusunda `object` ve `dynamic` türleri eşdeğer kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-127">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="f7b28-128">Ancak dinamik dönüştürmeler ([örtük dinamik dönüştürmeler](conversions.md#implicit-dynamic-conversions) ve [Açık dinamik dönüştürmeler](conversions.md#explicit-dynamic-conversions)) yalnızca `dynamic` türündeki ifadeler için geçerlidir ([dinamik tür](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="f7b28-128">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="f7b28-129">Kimlik dönüştürme</span><span class="sxs-lookup"><span data-stu-id="f7b28-129">Identity conversion</span></span>

<span data-ttu-id="f7b28-130">Bir kimlik dönüştürmesi herhangi bir türden aynı türe dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-130">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="f7b28-131">Bu dönüştürme, zaten gerekli bir türü olan bir varlığın bu türe dönüştürülebilir olduğunu söylebilmelidir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-131">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="f7b28-132">`object` ve `dynamic` eşit kabul edildiğinden, `object` ve `dynamic`arasında bir kimlik dönüştürmesi ve tüm `dynamic` tekrarlarının `object`ile değiştirilmesi sırasında aynı olan oluşturulmuş türler arasında.</span><span class="sxs-lookup"><span data-stu-id="f7b28-132">Because `object` and `dynamic` are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="f7b28-133">Örtük Sayısal dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-133">Implicit numeric conversions</span></span>

<span data-ttu-id="f7b28-134">Örtük Sayısal dönüştürmeler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-134">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="f7b28-135">`sbyte` `short`, `int`, `long`, `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-135">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-136">`byte` `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-136">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-137">`short` `int`, `long`, `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-137">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-138">`ushort` `int`, `uint`, `long`, `ulong`, `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-138">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-139">`int` `long`, `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-139">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-140">`uint` `long`, `ulong`, `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-140">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-141">`long` `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-141">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-142">`ulong` `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-142">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-143">`char` `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-143">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-144">`float` `double`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-144">From `float` to `double`.</span></span>

<span data-ttu-id="f7b28-145">`int`, `uint`, `long`ya da `ulong` arasında dönüştürme `float` ve `long` ya da `ulong` `double`, bir duyarlık kaybına neden olabilir, ancak hiçbir şekilde bir büyüklük kaybına neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="f7b28-145">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="f7b28-146">Diğer örtük sayısal dönüştürmeler hiçbir bilgiyi hiçbir şekilde kaybetmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-146">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="f7b28-147">`char` türüne örtük dönüştürmeler yoktur, bu nedenle diğer integral türlerin değerleri otomatik olarak `char` türüne dönüştürülemez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-147">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="f7b28-148">Örtük numaralandırma dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-148">Implicit enumeration conversions</span></span>

<span data-ttu-id="f7b28-149">Örtük bir numaralandırma dönüştürmesi, *decimal_integer_literal* `0`, temel alınan türü *enum_type*olan herhangi bir *enum_type* ve herhangi bir *nullable_type* dönüştürülmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-149">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="f7b28-150">İkinci durumda, dönüştürme temel *enum_type* dönüştürülürken değerlendirilir ve sonuç ([null yapılabilir türler](types.md#nullable-types)) sarmalanacaktır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-150">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="f7b28-151">Örtülü olarak bulunan dize dönüşümleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-151">Implicit interpolated string conversions</span></span>

<span data-ttu-id="f7b28-152">Örtük bir enterpolasyonlu dize dönüştürme *interpolated_string_expression* ([enterpolasyonlu dizeler](expressions.md#interpolated-strings)) `System.IFormattable` veya `System.FormattableString` (`System.IFormattable`uygulayan) biçimine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-152">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="f7b28-153">Bu dönüştürme uygulandığında, bir dize değeri, enterpolasyonlu dizeden oluşamaz.</span><span class="sxs-lookup"><span data-stu-id="f7b28-153">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="f7b28-154">Bunun yerine, bir `System.FormattableString` örneği, [enterpolasyonlu dizelerde](expressions.md#interpolated-strings)açıklanacak şekilde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-154">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="f7b28-155">Örtük null yapılabilir dönüşümler</span><span class="sxs-lookup"><span data-stu-id="f7b28-155">Implicit nullable conversions</span></span>

<span data-ttu-id="f7b28-156">Null olamayan değer türlerinde çalışan önceden tanımlanmış örtük dönüştürmeler, bu türlerin null atanabilir formlarıyla de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-156">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="f7b28-157">`S` null olmayan bir değer türünden `T`null değeri alamayan bir değer türüne dönüştüren, önceden tanımlanmış örtük kimlik ve sayısal dönüştürmelerin her biri için, aşağıdaki örtük null yapılabilir dönüşümler mevcuttur:</span><span class="sxs-lookup"><span data-stu-id="f7b28-157">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="f7b28-158">`S?` 'den `T?`örtülü dönüşüm.</span><span class="sxs-lookup"><span data-stu-id="f7b28-158">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="f7b28-159">`S` 'den `T?`örtülü dönüşüm.</span><span class="sxs-lookup"><span data-stu-id="f7b28-159">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="f7b28-160">`S` ile `T` arasında temel alınan dönüştürmeye göre örtük olarak null yapılabilir dönüştürme değerlendirmesi aşağıdaki gibi devam eder:</span><span class="sxs-lookup"><span data-stu-id="f7b28-160">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="f7b28-161">Null yapılabilir dönüştürme `S?` `T?`:</span><span class="sxs-lookup"><span data-stu-id="f7b28-161">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="f7b28-162">Kaynak değeri null ise (`HasValue` özelliği false), sonuç `T?`türünün null değeridir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-162">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="f7b28-163">Aksi takdirde, dönüştürme `S?` `T``S` ' dan `S`' dan bir sarmalama olarak değerlendirilir ve ardından `T` ' dan `T?`' a kadar bir sarmalama ([null yapılabilir türler](types.md#nullable-types)) tarafından yapılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-163">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="f7b28-164">Null yapılabilir dönüştürme `S` `T?`ise, dönüştürme, temel alınan dönüşüm olarak `T` `S`, `T` ve `T?`arasında bir sarmalama izler olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-164">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="f7b28-165">Null değişmez değer dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-165">Null literal conversions</span></span>

<span data-ttu-id="f7b28-166">`null` değişmez değerinden herhangi bir null yapılabilir tür için örtük bir dönüştürme bulunur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-166">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="f7b28-167">Bu dönüştürme, belirtilen null yapılabilir türdeki null değeri ([null yapılabilir türler](types.md#nullable-types)) oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-167">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="f7b28-168">Örtük başvuru dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-168">Implicit reference conversions</span></span>

<span data-ttu-id="f7b28-169">Örtük başvuru dönüştürmeleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-169">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="f7b28-170">Herhangi bir *reference_type* `object` ve `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-170">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="f7b28-171">Herhangi bir *class_type* `S` herhangi bir *class_type* `T`, `S` tarafından belirtilen `T`elde edilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-171">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="f7b28-172">Herhangi bir *class_type* `S` *interface_type* `T``S` uygular.</span><span class="sxs-lookup"><span data-stu-id="f7b28-172">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="f7b28-173">Herhangi bir *interface_type* `S` herhangi bir *interface_type* `T`, `S` tarafından belirtilen `T`elde edilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-173">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="f7b28-174">Öğe türü `T` bir *array_type* `S` `SE` öğe türü `TE`*array_type* , aşağıdakilerin tümü doğru olarak belirtilmelidir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-174">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="f7b28-175">`S` ve `T` yalnızca öğe türünde farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-175">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="f7b28-176">Diğer bir deyişle, `S` ve `T` aynı sayıda boyuta sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-176">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="f7b28-177">`SE` ve `TE` her ikisi de *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="f7b28-177">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="f7b28-178">`SE` ' den `TE`örtük bir başvuru dönüştürmesi vardır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-178">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="f7b28-179">Herhangi bir *array_type* `System.Array` ve uyguladığı arabirimlere.</span><span class="sxs-lookup"><span data-stu-id="f7b28-179">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="f7b28-180">Tek boyutlu dizi türünden `S[]` `System.Collections.Generic.IList<T>` ve temel arabirimlerine `S`, örtülü bir kimlik veya başvuru dönüştürmesi olması şartıyla `T`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-180">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="f7b28-181">Herhangi bir *delegate_type* `System.Delegate` ve uyguladığı arabirimlere.</span><span class="sxs-lookup"><span data-stu-id="f7b28-181">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="f7b28-182">Null değişmez değerinden herhangi bir *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="f7b28-182">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="f7b28-183">Herhangi bir *reference_type* , bir *reference_type* `T0` örtük bir kimlik veya başvuru dönüştürmesi varsa ve `T0` `T`bir kimlik dönüştürmesi varsa *reference_type* `T`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-183">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="f7b28-184">Herhangi bir *reference_type* bir arabirime veya temsilci türüne dönüştürme, bir arabirim veya temsilci türü `T0` ve `T0` varyans-dönüştürülebilir ([varyans dönüştürme](interfaces.md#variance-conversion)`T`) `T`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-184">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="f7b28-185">Başvuru türleri olarak bilinen tür parametreleri içeren örtük dönüştürmeler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-185">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="f7b28-186">Tür parametreleri içeren örtük dönüştürmeler hakkında daha fazla ayrıntı için bkz. [tür parametreleri Içeren örtük dönüştürmeler](conversions.md#implicit-conversions-involving-type-parameters) .</span><span class="sxs-lookup"><span data-stu-id="f7b28-186">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="f7b28-187">Örtük başvuru dönüştürmeleri, her zaman başarılı olarak kanıtlanmış *reference_type*s arasındaki Dönüştürmelere sahiptir ve bu nedenle çalışma zamanında hiçbir denetim gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-187">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="f7b28-188">Başvuru dönüştürmeleri, örtük veya açık, dönüştürülmekte olan nesnenin başvuru kimliğini hiçbir şekilde değiştirmeyin.</span><span class="sxs-lookup"><span data-stu-id="f7b28-188">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="f7b28-189">Diğer bir deyişle, bir başvuru dönüştürmesi başvurunun türünü değiştiremeken, başvuruda bulunulan nesnenin türünü veya değerini hiçbir şekilde değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-189">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="f7b28-190">Paketleme dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-190">Boxing conversions</span></span>

<span data-ttu-id="f7b28-191">Kutulama dönüştürme bir *value_type* örtülü olarak bir başvuru türüne dönüştürülmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-191">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="f7b28-192">Herhangi bir *non_nullable_value_type* `object` ve `dynamic`, *interface_type*tarafından uygulanan *non_nullable_value_type* `System.ValueType` için bir paketleme dönüştürmesi vardır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-192">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="f7b28-193">Ayrıca, bir *enum_type* `System.Enum`türüne dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-193">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="f7b28-194">Bir *nullable_type* bir referans türüne, yalnızca temeldeki *non_nullable_value_type* başvuru türüne bir paketleme dönüştürmesi varsa, bir paketleme dönüştürmesi vardır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-194">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="f7b28-195">Bir değer türü, bir arabirim türüne paketleme dönüştürmesi varsa `I` bir arabirim türüne kutulama dönüştürmesi içerir `I0` ve `I0` bir kimlik dönüştürmesi `I`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="f7b28-196">Bir değer türünün, bir arabirime veya temsilci türüne paketleme dönüştürmesi varsa `I` bir arabirim türüne paketleme dönüştürmesi vardır `I0` ve `I0` varyans-dönüştürülebilir ([varyans dönüştürme](interfaces.md#variance-conversion)) `I`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-196">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="f7b28-197">Bir *non_nullable_value_type* değerini kutulama bir nesne örneği ayırmayı ve *value_type* değerini bu örneğe kopyalamayı içerir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-197">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="f7b28-198">Yapı, tüm yapılar ([Devralma](structs.md#inheritance)) için bir temel sınıf olduğundan `System.ValueType`türüne kutulanabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-198">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="f7b28-199">Bir *nullable_type* değerini kutulama aşağıdaki gibi devam eder:</span><span class="sxs-lookup"><span data-stu-id="f7b28-199">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="f7b28-200">Kaynak değer null ise (`HasValue` özelliği false), sonuç hedef türün null başvurusudur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-200">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="f7b28-201">Aksi takdirde, sonuç, kaynak değeri sarmalanmış ve paketleme tarafından oluşturulan kutulanmış `T` bir başvurudur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-201">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="f7b28-202">Paketleme dönüştürmeleri, [paketleme dönüştürmelerinde](types.md#boxing-conversions)daha ayrıntılı bir şekilde açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-202">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="f7b28-203">Örtük dinamik dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-203">Implicit dynamic conversions</span></span>

<span data-ttu-id="f7b28-204">`T`tür `dynamic` bir ifadeden örtük dinamik dönüştürme bulunur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-204">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="f7b28-205">Dönüştürme, dinamik olarak bağlı ([dinamik bağlama](expressions.md#dynamic-binding)), bu, örtük bir dönüştürmenin `T`, ifadenin çalışma zamanı türünden çalışma zamanında arayacaktır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-205">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="f7b28-206">Dönüştürme bulunamazsa, bir çalışma zamanı özel durumu oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-206">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="f7b28-207">Örtülü dönüştürmenin, örtük [dönüştürmelerin](conversions.md#implicit-conversions) başlangıcında asla bir özel duruma neden olmaması gerektiğine ilişkin önerileri ihlal ettiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f7b28-207">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="f7b28-208">Ancak dönüştürmenin kendisi değil, özel duruma neden olan dönüştürmenin *bulunması* değildir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-208">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="f7b28-209">Çalışma zamanı özel durumlarının riski dinamik bağlama kullanımına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-209">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="f7b28-210">Dönüştürmenin dinamik bağlaması istenmiyorsa, ifade önce `object`ve ardından istenen türe dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-210">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="f7b28-211">Aşağıdaki örnekte örtük dinamik dönüştürmeler gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-211">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="f7b28-212">`s2` ve `i` atamaları her ikisi de, çalışma zamanına kadar işlemlerin bağlantısının askıya alındığı örtük dinamik dönüştürmeler kullanmayı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f7b28-212">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="f7b28-213">Çalışma zamanında örtük dönüştürmeler, hedef türe `string` `d` -- çalışma zamanı türünden alınır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-213">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="f7b28-214">`string` bir dönüştürme bulunur, ancak `int`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-214">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="f7b28-215">Örtük sabit ifade dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-215">Implicit constant expression conversions</span></span>

<span data-ttu-id="f7b28-216">Örtük bir sabit ifade dönüştürmesi aşağıdaki Dönüştürmelere izin verir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-216">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="f7b28-217">`int` türündeki *constant_expression* ([sabit ifadeler](expressions.md#constant-expressions)) `sbyte`, `byte`, `short`, `ushort`, `uint`veya `ulong`türüne dönüştürülebilir. Bu değer, *constant_expression* değeri hedef türünün aralığı dahilinde.</span><span class="sxs-lookup"><span data-stu-id="f7b28-217">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="f7b28-218">`long` türündeki *constant_expression* `ulong`türüne dönüştürülebilir, ancak *constant_expression* değeri negatif değil.</span><span class="sxs-lookup"><span data-stu-id="f7b28-218">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="f7b28-219">Tür parametreleri içeren örtük dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-219">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="f7b28-220">Verilen tür parametresi için aşağıdaki örtük dönüştürmeler mevcuttur `T`:</span><span class="sxs-lookup"><span data-stu-id="f7b28-220">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="f7b28-221">`T`, `T` temel `C`ve `T` tarafından uygulanan bir arabirime `C`geçerli temel sınıfına.</span><span class="sxs-lookup"><span data-stu-id="f7b28-221">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="f7b28-222">Çalışma zamanında, `T` bir değer türü ise, dönüştürme paketleme dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-222">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="f7b28-223">Aksi takdirde, dönüştürme örtük bir başvuru dönüştürmesi veya kimlik dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-223">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="f7b28-224">`T`, `T`etkin arabirim kümesinde ve `T` `I`herhangi bir taban arabirimine `I` bir arabirim türüne.</span><span class="sxs-lookup"><span data-stu-id="f7b28-224">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="f7b28-225">Çalışma zamanında, `T` bir değer türü ise, dönüştürme paketleme dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-225">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="f7b28-226">Aksi takdirde, dönüştürme örtük bir başvuru dönüştürmesi veya kimlik dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-226">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="f7b28-227">`T`, `U`bir tür parametresine `T` `U` ([tür parametre kısıtlamalarına](classes.md#type-parameter-constraints)) bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-227">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="f7b28-228">Çalışma zamanında, `U` bir değer türü ise, `T` ve `U` aynı türde ve hiçbir dönüştürme gerçekleştirilmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-228">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="f7b28-229">Aksi takdirde, `T` bir değer türü ise, dönüştürme paketleme dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-229">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="f7b28-230">Aksi takdirde, dönüştürme örtük bir başvuru dönüştürmesi veya kimlik dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-230">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="f7b28-231">Null değişmez değerinden `T`, `T` belirtilen bir başvuru türü olduğu bilinmektedir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-231">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="f7b28-232">`T`, bir başvuru türüne örtük bir dönüştürme içeriyorsa ve `S0` `S`'ye bir kimlik dönüştürmesi varsa `I` bir başvuru türüne `S0`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-232">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="f7b28-233">Çalışma zamanında dönüştürme `S0`dönüştürme ile aynı şekilde yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-233">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="f7b28-234">`T`, bir arabirim veya temsilci türüne örtülü olarak dönüştürme içeriyorsa ve `I0` varyans-`I` dönüştürülebilir ([varyans dönüştürmesi](interfaces.md#variance-conversion)) `I` bir arabirim türüne `I0`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-234">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="f7b28-235">Çalışma zamanında, `T` bir değer türü ise, dönüştürme paketleme dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-235">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="f7b28-236">Aksi takdirde, dönüştürme örtük bir başvuru dönüştürmesi veya kimlik dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-236">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="f7b28-237">`T` bir başvuru türü ([tür parametresi kısıtlamaları](classes.md#type-parameter-constraints)) olarak bilindiğinde, yukarıdaki dönüşümler tamamen örtük başvuru dönüştürmeleri ([örtük başvuru dönüştürmeleri](conversions.md#implicit-reference-conversions)) olarak sınıflandırılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-237">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="f7b28-238">`T` bir başvuru türü olarak bilinmiyorsa, yukarıdaki dönüştürmeler paketleme dönüştürmeleri ([kutulama dönüştürmeleri](conversions.md#boxing-conversions)) olarak sınıflandırılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-238">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="f7b28-239">Kullanıcı tanımlı örtük dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-239">User-defined implicit conversions</span></span>

<span data-ttu-id="f7b28-240">Kullanıcı tanımlı örtük dönüştürme, isteğe bağlı standart bir örtük dönüştürme, ardından Kullanıcı tanımlı örtük dönüştürme işlecinin yürütülmesi ve ardından isteğe bağlı bir standart örtük dönüştürme ile oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-240">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="f7b28-241">Kullanıcı tanımlı örtük dönüştürmeleri değerlendirmek için tam kurallar, [Kullanıcı tanımlı örtük dönüştürmelerin işlenmesinde](conversions.md#processing-of-user-defined-implicit-conversions)açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-241">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="f7b28-242">Anonim işlev dönüştürmeleri ve Yöntem grubu dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-242">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="f7b28-243">Anonim işlevler ve yöntem grupları, ve içinde türlerine sahip değildir, ancak dolaylı olarak temsilci türlerine veya ifade ağaç türlerine dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-243">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="f7b28-244">Anonim işlev dönüştürmeleri, [metot grubu dönüştürmelerinde](conversions.md#method-group-conversions) [Adsız işlev dönüştürmelerinde](conversions.md#anonymous-function-conversions) ve Yöntem grubu dönüştürmelerinde daha ayrıntılı bir şekilde açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-244">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="f7b28-245">Açık dönüşümler</span><span class="sxs-lookup"><span data-stu-id="f7b28-245">Explicit conversions</span></span>

<span data-ttu-id="f7b28-246">Aşağıdaki dönüşümler açık dönüştürmeler olarak sınıflandırılmaktadır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-246">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="f7b28-247">Tüm örtük dönüştürmeler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-247">All implicit conversions.</span></span>
*  <span data-ttu-id="f7b28-248">Açık sayısal dönüştürmeler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-248">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="f7b28-249">Açık sabit listesi dönüştürmeleri.</span><span class="sxs-lookup"><span data-stu-id="f7b28-249">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="f7b28-250">Açık boş değer atanabilir dönüşümler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-250">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="f7b28-251">Açık başvuru dönüştürmeleri.</span><span class="sxs-lookup"><span data-stu-id="f7b28-251">Explicit reference conversions.</span></span>
*  <span data-ttu-id="f7b28-252">Açık arabirim dönüştürmeleri.</span><span class="sxs-lookup"><span data-stu-id="f7b28-252">Explicit interface conversions.</span></span>
*  <span data-ttu-id="f7b28-253">Kutudan çıkarma dönüştürmeleri.</span><span class="sxs-lookup"><span data-stu-id="f7b28-253">Unboxing conversions.</span></span>
*  <span data-ttu-id="f7b28-254">Açık dinamik dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-254">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="f7b28-255">Kullanıcı tanımlı açık dönüştürmeler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-255">User-defined explicit conversions.</span></span>

<span data-ttu-id="f7b28-256">Dönüştürme ifadelerinde açık dönüştürmeler oluşabilir ([atama ifadeleri](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="f7b28-256">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="f7b28-257">Açık dönüştürmeler kümesi tüm örtük dönüştürmeleri içerir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-257">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="f7b28-258">Bu, gereksiz atama ifadelerine izin verilen anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-258">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="f7b28-259">Örtük dönüştürmeler olmayan açık dönüştürmeler, her zaman başarılı olmak üzere kendini kanıtlanamaz dönüşümlerdir, bilinen dönüştürmeler, büyük olasılıkla bilgi kaybedecektir ve türlerin etki alanları arasında dönüştürme imle.</span><span class="sxs-lookup"><span data-stu-id="f7b28-259">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="f7b28-260">Açık sayısal dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-260">Explicit numeric conversions</span></span>

<span data-ttu-id="f7b28-261">Açık sayısal dönüştürmeler, bir *numeric_type* örtük bir sayısal dönüştürmenin ([örtük sayısal dönüştürmeler](conversions.md#implicit-numeric-conversions)) zaten mevcut olmadığı başka bir *numeric_type* dönüşümlerdir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-261">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="f7b28-262">`sbyte` `byte`, `ushort`, `uint`, `ulong`veya `char`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-262">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="f7b28-263">`byte` `sbyte` ve `char`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-263">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="f7b28-264">`short` `sbyte`, `byte`, `ushort`, `uint`, `ulong`veya `char`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-264">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="f7b28-265">`ushort` `sbyte`, `byte`, `short`veya `char`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-265">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="f7b28-266">`int` `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`veya `char`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-266">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="f7b28-267">`uint` `sbyte`, `byte`, `short`, `ushort`, `int`veya `char`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-267">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="f7b28-268">`long` `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`veya `char`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-268">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="f7b28-269">`ulong` `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`veya `char`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-269">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="f7b28-270">`char` `sbyte`, `byte`veya `short`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-270">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="f7b28-271">`float` `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-271">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-272">`double` `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-272">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-273">`decimal` `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`veya `double`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-273">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="f7b28-274">Açık dönüştürmeler tüm örtük ve açık sayısal dönüştürmeleri içerdiğinden, herhangi bir *numeric_type* bir atama Ifadesi ([atama ifadeleri](expressions.md#cast-expressions)) kullanarak herhangi bir numeric_type başka bir dönüştürmek her zaman mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-274">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="f7b28-275">Açık sayısal dönüştürmeler büyük olasılıkla bilgileri kaybedebilir veya büyük olasılıkla özel durumların oluşturulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-275">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="f7b28-276">Açık bir sayısal dönüştürme şu şekilde işlenir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-276">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="f7b28-277">İntegral türünden başka bir integral türüne dönüştürme işlemi için işleme, dönüştürmenin gerçekleştiği taşma Denetim bağlamına ([denetlenen ve işaretlenmemiş operatörler](expressions.md#the-checked-and-unchecked-operators)) bağlıdır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-277">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="f7b28-278">`checked` bağlamında, kaynak işlenenin değeri hedef türü Aralık içindeyse, ancak kaynak işlenenin değeri hedef türü aralığının dışında bir `System.OverflowException` oluşturduğunda dönüştürme başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-278">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="f7b28-279">`unchecked` bağlamında, dönüştürme her zaman başarılı olur ve aşağıdaki gibi devam eder.</span><span class="sxs-lookup"><span data-stu-id="f7b28-279">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="f7b28-280">Kaynak türü hedef türünden büyükse, "ekstra" en önemli bitleri atarak kaynak değer kesilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-280">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="f7b28-281">Sonuç daha sonra hedef türünün bir değeri olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-281">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="f7b28-282">Kaynak türü hedef türünden küçükse, hedef türle aynı boyutta olması için, kaynak değeri ya imza veya sıfır genişletilmiş ya da sıfır genişletilmiş olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-282">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="f7b28-283">Kaynak türü imzalanmışsa, oturum açma uzantısı kullanılır; Kaynak türü işaretsiz ise sıfır uzantı kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-283">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="f7b28-284">Sonuç daha sonra hedef türünün bir değeri olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-284">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="f7b28-285">Kaynak türü hedef türle aynı boyutta ise, kaynak değer hedef türün bir değeri olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-285">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="f7b28-286">`decimal` bir integral türüne dönüştürme için, kaynak değer en yakın tamsayı değerine sıfır doğru yuvarlanır ve bu tam sayı değeri dönüştürmenin sonucu olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-286">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="f7b28-287">Elde edilen integral değeri, hedef türü aralığının dışındaysa bir `System.OverflowException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-287">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="f7b28-288">`float` veya `double` bir integral türüne dönüştürme için, işleme, dönüştürmenin gerçekleştiği taşma Denetim bağlamına ([denetlenen ve işaretlenmemiş operatörler](expressions.md#the-checked-and-unchecked-operators)) bağlıdır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-288">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="f7b28-289">`checked` bağlamında, dönüştürme aşağıdaki gibi devam eder:</span><span class="sxs-lookup"><span data-stu-id="f7b28-289">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="f7b28-290">İşlenenin değeri NaN veya sonsuz ise, bir `System.OverflowException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-290">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="f7b28-291">Aksi takdirde, kaynak işleneni en yakın tamsayı değerine sıfır doğru yuvarlanır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-291">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="f7b28-292">Bu integral değeri hedef türünün aralığı içindeyse, bu değer dönüştürmenin sonucudur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-292">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="f7b28-293">Aksi takdirde, bir `System.OverflowException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-293">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="f7b28-294">`unchecked` bağlamında, dönüştürme her zaman başarılı olur ve aşağıdaki gibi devam eder.</span><span class="sxs-lookup"><span data-stu-id="f7b28-294">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="f7b28-295">İşlenenin değeri NaN veya sonsuz ise, dönüştürmenin sonucu hedef türün belirtilmemiş bir değeridir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-295">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="f7b28-296">Aksi takdirde, kaynak işleneni en yakın tamsayı değerine sıfır doğru yuvarlanır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-296">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="f7b28-297">Bu integral değeri hedef türünün aralığı içindeyse, bu değer dönüştürmenin sonucudur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-297">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="f7b28-298">Aksi takdirde, dönüştürmenin sonucu hedef türün belirtilmemiş bir değeridir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-298">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="f7b28-299">`double` `float`bir dönüştürme için `double` değeri en yakın `float` değerine yuvarlanır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-299">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="f7b28-300">`double` değeri `float`olarak temsil etmek için çok küçükse, sonuç pozitif sıfır veya negatif sıfır olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-300">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="f7b28-301">`double` değeri `float`olarak temsil etmek için çok büyükse, sonuç pozitif sonsuzluk veya negatif sonsuzluk olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-301">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="f7b28-302">`double` değeri NaN ise, sonuç de NaN olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-302">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="f7b28-303">`float` veya `double` `decimal`'e dönüştürme için, kaynak değer `decimal` gösterimine dönüştürülür ve gerekirse 28 ondalık konumundan sonra en yakın sayıya yuvarlanır ([ondalık türü](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="f7b28-303">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="f7b28-304">Kaynak değeri `decimal`olarak temsil etmek için çok küçükse, sonuç sıfır olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-304">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="f7b28-305">Kaynak değeri NaN, Infinity veya `decimal`olarak temsil edilebilmesi için çok büyükse, bir `System.OverflowException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-305">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="f7b28-306">`decimal` `float` veya `double`'e dönüştürme için `decimal` değeri en yakın `double` veya `float` değerine yuvarlanır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-306">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="f7b28-307">Bu dönüştürme duyarlığı kaybedebilir, ancak hiçbir durum özel durum oluşturulmasına neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="f7b28-307">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="f7b28-308">Açık sabit listesi dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-308">Explicit enumeration conversions</span></span>

<span data-ttu-id="f7b28-309">Açık numaralandırma dönüştürmeleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-309">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="f7b28-310">`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`veya `decimal` herhangi bir *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="f7b28-310">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="f7b28-311">Herhangi bir *enum_type* `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-311">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="f7b28-312">Herhangi bir *enum_type* başka bir *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="f7b28-312">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="f7b28-313">İki tür arasında açık bir sabit listesi dönüştürme işlemi, herhangi bir katılım *enum_type* , bu *enum_type*temel alınan türü olarak davranarak işlenir ve ardından sonuçtaki türler arasında örtük veya açık bir sayısal dönüştürme gerçekleştirerek.</span><span class="sxs-lookup"><span data-stu-id="f7b28-313">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="f7b28-314">Örneğin, *enum_type* `E` ve temel alınan `int`türü verildiğinde, `E` 'den `byte` 'ye dönüştürme, `int` 'den `byte`'e açık bir sayısal dönüştürme ([Açık sayısal dönüştürmeler](conversions.md#explicit-numeric-conversions)) olarak işlenir ve `byte` 'den `E` 'ye dönüştürme işlemi `byte` 'den `int`örtülü bir sayısal dönüştürme ([örtük sayısal dönüştürmeler](conversions.md#implicit-numeric-conversions)) olarak işlenir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-314">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="f7b28-315">Açık boş değer atanabilir dönüşümler</span><span class="sxs-lookup"><span data-stu-id="f7b28-315">Explicit nullable conversions</span></span>

<span data-ttu-id="f7b28-316">***Açık null yapılabilir dönüşümler*** , null olamayan değer türlerinde çalışan önceden tanımlı açık Dönüştürmelere izin verir ve bu türlerin null yapılabilir formlarıyla de kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-316">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="f7b28-317">Null yapılamayan bir değer türünden `S`, null olamayan bir değer türü `T` ([kimlik dönüştürme](conversions.md#identity-conversion), [örtük sayısal dönüştürmeler](conversions.md#implicit-numeric-conversions), [örtük numaralandırma dönüştürmeleri](conversions.md#implicit-enumeration-conversions), [Açık sayısal dönüştürmeler](conversions.md#explicit-numeric-conversions)ve [Açık sabit listesi dönüştürmeleri](conversions.md#explicit-enumeration-conversions)) dönüştüren önceden tanımlanmış açık dönüştürmelerin her biri için, aşağıdaki null yapılabilir dönüşümler mevcuttur:</span><span class="sxs-lookup"><span data-stu-id="f7b28-317">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="f7b28-318">`S?` ' den `T?`açık bir dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="f7b28-318">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="f7b28-319">`S` ' den `T?`açık bir dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="f7b28-319">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="f7b28-320">`S?` ' den `T`açık bir dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="f7b28-320">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="f7b28-321">`S` ile `T` arasında temel alınan dönüştürmeye göre null yapılabilir dönüştürme değerlendirmesi aşağıdaki gibi devam eder:</span><span class="sxs-lookup"><span data-stu-id="f7b28-321">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="f7b28-322">Null yapılabilir dönüştürme `S?` `T?`:</span><span class="sxs-lookup"><span data-stu-id="f7b28-322">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="f7b28-323">Kaynak değeri null ise (`HasValue` özelliği false), sonuç `T?`türünün null değeridir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-323">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="f7b28-324">Aksi takdirde, dönüştürme `S?` `T``S` ' den `S`' dan bir sarmalama olarak değerlendirilir ve ardından `T` ' den `T?`' a bir sarmalama tarafından yapılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-324">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="f7b28-325">Null yapılabilir dönüştürme `S` `T?`ise, dönüştürme, temel alınan dönüşüm olarak `T` `S`, `T` ve `T?`arasında bir sarmalama izler olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-325">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="f7b28-326">Null yapılabilir dönüştürme `S?` `T`ise, dönüştürme `S?` ' dan bir sarmalama olarak değerlendirilir `S` ve `S` ' den `T`' e doğru dönüştürme olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-326">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="f7b28-327">Null yapılabilir bir değeri sarmalama girişimi, değer `null`bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-327">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="f7b28-328">Açık başvuru dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-328">Explicit reference conversions</span></span>

<span data-ttu-id="f7b28-329">Açık başvuru dönüştürmeleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-329">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="f7b28-330">`object` ve `dynamic` diğer *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="f7b28-330">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="f7b28-331">Herhangi bir *class_type* `S` herhangi bir *class_type* `T`, `S` bir `T`taban sınıfıdır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-331">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="f7b28-332">Herhangi bir *class_type* `S` herhangi bir *interface_type* `T`, `S`, ve `S` `T`uygulamaz.</span><span class="sxs-lookup"><span data-stu-id="f7b28-332">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="f7b28-333">Herhangi bir *interface_type* `S` herhangi bir *class_type* `T`için, `T`, `T` `S`uygulayan.</span><span class="sxs-lookup"><span data-stu-id="f7b28-333">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="f7b28-334">Herhangi bir *interface_type* `S` herhangi bir *interface_type* `T``S`, belirtilen `T`türetilmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-334">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="f7b28-335">Öğe türü `T` bir *array_type* `S` `SE` öğe türü `TE`*array_type* , aşağıdakilerin tümü doğru olarak belirtilmelidir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-335">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="f7b28-336">`S` ve `T` yalnızca öğe türünde farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-336">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="f7b28-337">Diğer bir deyişle, `S` ve `T` aynı sayıda boyuta sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-337">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="f7b28-338">`SE` ve `TE` her ikisi de *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="f7b28-338">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="f7b28-339">`SE` `TE`bir açık başvuru dönüştürmesi vardır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-339">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="f7b28-340">`System.Array` ve uyguladığı arabirimler *array_type*.</span><span class="sxs-lookup"><span data-stu-id="f7b28-340">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="f7b28-341">Tek boyutlu dizi türünden `System.Collections.Generic.IList<T>` ve temel arabirimlerine `S[]`, `S` bir açık başvuru dönüştürmesi olması şartıyla `T`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-341">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="f7b28-342">`System.Collections.Generic.IList<S>` ve temel arabirimlerinden `T[]`, `T``S` bir açık kimlik veya başvuru dönüştürmesi olması şartıyla, tek boyutlu bir dizi türüne.</span><span class="sxs-lookup"><span data-stu-id="f7b28-342">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="f7b28-343">`System.Delegate` ve uyguladığı arabirimler *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="f7b28-343">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="f7b28-344">Başvuru türü olan bir başvuru türüne `T`, bir başvuru türü `T0` açık başvuru dönüştürmesi varsa ve `T0` bir kimlik dönüştürme `T`sahipse</span><span class="sxs-lookup"><span data-stu-id="f7b28-344">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="f7b28-345">Bir arabirim veya temsilci türüne açık başvuru dönüştürmesi varsa, bir başvuru türünden bir arabirime veya temsilci türüne `T` `T0` ve `T0` fark-`T` dönüştürülebilir ya da `T` ([varyans dönüştürmesi](interfaces.md#variance-conversion)) arasında değişim yapılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-345">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="f7b28-346">`D<S1...Sn>`, `D<X1...Xn>` genel bir temsilci türü olduğu `D<T1...Tn>`, `D<S1...Sn>` `D<T1...Tn>`ile uyumlu değil ve `Xi` her bir tür parametresi için `D` aşağıdaki tutmalar:</span><span class="sxs-lookup"><span data-stu-id="f7b28-346">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="f7b28-347">`Xi` sabit ise, `Si` `Ti`aynıdır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-347">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="f7b28-348">`Xi` covaryant ise, örtülü veya açık bir kimlik ya da `Si` `Ti`'e başvuru dönüştürmesi vardır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-348">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="f7b28-349">`Xi` değişken karşıtı ise, `Si` ve `Ti` aynı ya da her iki başvuru türü olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-349">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="f7b28-350">Başvuru türleri olarak bilinen tür parametreleri içeren açık dönüştürmeler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-350">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="f7b28-351">Tür parametreleriyle ilgili açık dönüştürmeler hakkında daha fazla ayrıntı için bkz. [tür parametreleri Içeren açık dönüştürmeler](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="f7b28-351">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="f7b28-352">Açık başvuru dönüştürmeleri, doğru olduklarından emin olmak için çalışma zamanı denetimleri gerektiren başvuru türleri arasındaki dönüşümlerdir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-352">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="f7b28-353">Açık bir başvuru dönüştürmenin çalışma zamanında başarılı olması için, kaynak işlenenin değeri `null`olmalı veya kaynak işleneni tarafından başvurulan nesnenin gerçek türü, örtük bir başvuru dönüştürmesi ([örtük başvuru dönüştürmeleri](conversions.md#implicit-reference-conversions)) veya paketleme dönüştürmesi ([kutulama dönüştürmeleri](conversions.md#boxing-conversions)) tarafından hedef türe dönüştürülebilen bir tür olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-353">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="f7b28-354">Açık bir başvuru dönüştürmesi başarısız olursa, bir `System.InvalidCastException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-354">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="f7b28-355">Başvuru dönüştürmeleri, örtük veya açık, dönüştürülmekte olan nesnenin başvuru kimliğini hiçbir şekilde değiştirmeyin.</span><span class="sxs-lookup"><span data-stu-id="f7b28-355">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="f7b28-356">Diğer bir deyişle, bir başvuru dönüştürmesi başvurunun türünü değiştiremeken, başvuruda bulunulan nesnenin türünü veya değerini hiçbir şekilde değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-356">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="f7b28-357">Kutudan çıkarma dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-357">Unboxing conversions</span></span>

<span data-ttu-id="f7b28-358">Kutudan çıkarma dönüştürmesi, bir başvuru türünün açıkça bir *value_type*dönüştürülmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-358">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="f7b28-359">Türler `object`, `dynamic` ve `System.ValueType` herhangi bir *non_nullable_value_type* *ve interface_type uygulayan tüm non_nullable_value_type için bir* kutudan çıkarma dönüştürmesi *vardır.*</span><span class="sxs-lookup"><span data-stu-id="f7b28-359">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="f7b28-360">Ayrıca tür `System.Enum` herhangi bir *enum_type*kutulanabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-360">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="f7b28-361">Başvuru türünden *nullable_type*temel *non_nullable_value_type* bir kutudan çıkarma dönüştürmesi varsa, bir başvuru türünden bir paket açma dönüştürmesi *nullable_type* vardır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-361">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="f7b28-362">`S` değer türü bir arabirim türünden kutudan çıkarma dönüştürmesi varsa `I` bir arabirim türü `I0` ve `I0` `I`bir kimlik dönüştürmesi varsa.</span><span class="sxs-lookup"><span data-stu-id="f7b28-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="f7b28-363">Bir değer türü `S` bir arabirim türünden bir paket açma dönüştürmesi varsa `I`, `I0` bir arabirim veya temsilci türünden bir paket açma dönüştürmesi varsa ve `I0` varyans-dönüştürülebilir veya `I`, `I` ([varyans dönüştürmesi](interfaces.md#variance-conversion)) olarak değiştirildi.</span><span class="sxs-lookup"><span data-stu-id="f7b28-363">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="f7b28-364">Kutudan çıkarma işlemi, nesne örneğinin verilen *value_type*kutulanmış bir değer olup olmadığını kontrol ederek değeri örnekten dışarı kopyalamaktan oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-364">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="f7b28-365">Bir *nullable_type* null başvurusunun kutudan çıkarma *nullable_type*null değeri üretir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-365">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="f7b28-366">Bir struct, tüm yapılar ([Devralma](structs.md#inheritance)) için bir temel sınıf olduğundan `System.ValueType`türünden kutulanabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-366">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="f7b28-367">Kutudan çıkarma dönüştürmeleri, kutudan çıkarma [dönüştürmelerinde](types.md#unboxing-conversions)açıklanacaktır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-367">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="f7b28-368">Açık dinamik dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-368">Explicit dynamic conversions</span></span>

<span data-ttu-id="f7b28-369">`T`tür `dynamic` bir ifadeden açık dinamik dönüştürme bulunur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-369">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="f7b28-370">Dönüştürme, dinamik olarak bağlı ([dinamik bağlama](expressions.md#dynamic-binding)), yani `T`için ifadenin çalışma zamanı türünden çalışma zamanında açık bir dönüştürme yapılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-370">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="f7b28-371">Dönüştürme bulunamazsa, bir çalışma zamanı özel durumu oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-371">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="f7b28-372">Dönüştürmenin dinamik bağlaması istenmiyorsa, ifade önce `object`ve ardından istenen türe dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-372">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="f7b28-373">Aşağıdaki sınıfın tanımlandığını varsayalım:</span><span class="sxs-lookup"><span data-stu-id="f7b28-373">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="f7b28-374">Aşağıdaki örnekte açık dinamik dönüştürmeler gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-374">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="f7b28-375">`C` `o` en iyi dönüşümü, derleme zamanında açık bir başvuru dönüştürmesi olacak şekilde bulunur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-375">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="f7b28-376">`"1"` aslında bir `C`olmadığından, çalışma zamanında bu başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-376">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="f7b28-377">`d` `C` ancak açık dinamik dönüştürme olarak dönüştürme işlemi, `d` -- `string`---arasında bir Kullanıcı tanımlı dönüştürme olduğu ve başarılı olduğu zaman çalışma zamanına askıya alınır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-377">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="f7b28-378">Tür parametreleri içeren açık dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-378">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="f7b28-379">Verilen tür parametresi için aşağıdaki açık dönüştürmeler mevcuttur `T`:</span><span class="sxs-lookup"><span data-stu-id="f7b28-379">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="f7b28-380">`T` `C` geçerli taban sınıftan `T` ve `C` herhangi bir taban sınıftan `T`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-380">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="f7b28-381">Çalışma zamanında, `T` bir değer türü ise, dönüştürme bir kutudan çıkarma dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-381">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="f7b28-382">Aksi takdirde, dönüştürme açık bir başvuru dönüştürmesi veya kimlik dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-382">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="f7b28-383">Herhangi bir arabirim türünden `T`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-383">From any interface type to `T`.</span></span> <span data-ttu-id="f7b28-384">Çalışma zamanında, `T` bir değer türü ise, dönüştürme bir kutudan çıkarma dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-384">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="f7b28-385">Aksi takdirde, dönüştürme açık bir başvuru dönüştürmesi veya kimlik dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-385">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="f7b28-386">`T` *interface_type* `I`, `T` ' den `I`'e örtük bir dönüştürme olmadığı için.</span><span class="sxs-lookup"><span data-stu-id="f7b28-386">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="f7b28-387">Çalışma zamanında, `T` bir değer türü ise, dönüştürme bir paketleme dönüştürmesi ve ardından açık bir başvuru dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-387">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="f7b28-388">Aksi takdirde, dönüştürme açık bir başvuru dönüştürmesi veya kimlik dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-388">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="f7b28-389">Bir tür parametresi `T``U`, `T` belirtilen `U` ([tür parametresi kısıtlamaları](classes.md#type-parameter-constraints)) bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-389">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="f7b28-390">Çalışma zamanında, `U` bir değer türü ise, `T` ve `U` aynı türde ve hiçbir dönüştürme gerçekleştirilmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-390">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="f7b28-391">Aksi takdirde, `T` bir değer türü ise, dönüştürme bir kutudan çıkarma dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-391">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="f7b28-392">Aksi takdirde, dönüştürme açık bir başvuru dönüştürmesi veya kimlik dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-392">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="f7b28-393">`T` bir başvuru türü olarak bilindiğinde, yukarıdaki dönüşümler tamamen açık başvuru dönüştürmeleri ([açık başvuru dönüştürmeleri](conversions.md#explicit-reference-conversions)) olarak sınıflandırılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-393">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="f7b28-394">`T` bir başvuru türü olarak bilinmiyorsa, yukarıdaki dönüştürmeler kutudan çıkarma dönüştürmeleri ([kutudan çıkarma dönüştürmeleri](conversions.md#unboxing-conversions)) olarak sınıflandırılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-394">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="f7b28-395">Yukarıdaki kurallar, kısıtlanmamış bir tür parametresinden doğrudan açık dönüştürmeye, arabirim olmayan bir türe izin vermez, bu da şaşırtıcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-395">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="f7b28-396">Bu kuralın nedeni karışıklığa engel olmak ve bu tür dönüştürmelerin semantiğini temizlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-396">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="f7b28-397">Örneğin, aşağıdaki bildirimi ele alalım:</span><span class="sxs-lookup"><span data-stu-id="f7b28-397">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="f7b28-398">`int` `t` doğrudan açık dönüştürmeye izin verildiğinde, bir `X<int>.F(7)` `7L`döndürmesini kolayca bekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-398">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="f7b28-399">Ancak, Standart Sayısal Dönüşümler yalnızca türlerin bağlama sırasında sayısal olarak bilindiğinde kabul edildiği için değildir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-399">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="f7b28-400">Semantiğini açık hale getirmek için yukarıdaki örneğin yazılması gerekir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-400">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="f7b28-401">Bu kod artık derlenir, ancak `X<int>.F(7)` kutulanmış `int` doğrudan bir `long`dönüştürülemediğinden çalışma zamanında bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-401">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="f7b28-402">Kullanıcı tanımlı açık dönüşümler</span><span class="sxs-lookup"><span data-stu-id="f7b28-402">User-defined explicit conversions</span></span>

<span data-ttu-id="f7b28-403">Kullanıcı tanımlı açık dönüştürme, isteğe bağlı bir standart açık dönüşümden, ardından Kullanıcı tanımlı örtük veya açık bir dönüştürme işlecinin yürütülmesi ve ardından isteğe bağlı bir standart açık dönüştürme ile oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-403">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="f7b28-404">Kullanıcı tanımlı Açık dönüştürmeleri değerlendirmek için tam kurallar, [Kullanıcı tanımlı açık dönüştürmelerin işlenmesinde](conversions.md#processing-of-user-defined-explicit-conversions)açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-404">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="f7b28-405">Standart dönüşümler</span><span class="sxs-lookup"><span data-stu-id="f7b28-405">Standard conversions</span></span>

<span data-ttu-id="f7b28-406">Standart dönüştürmeler, Kullanıcı tanımlı dönüştürmenin bir parçası olarak gerçekleşebileceğini önceden tanımlanmış dönüşümlerdir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-406">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="f7b28-407">Standart örtük dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-407">Standard implicit conversions</span></span>

<span data-ttu-id="f7b28-408">Aşağıdaki örtük dönüştürmeler standart örtük dönüştürmeler olarak sınıflandırılmaktadır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-408">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="f7b28-409">Kimlik dönüştürmeleri ([kimlik dönüştürme](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="f7b28-409">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="f7b28-410">Örtük Sayısal Dönüşümler ([örtük sayısal dönüştürmeler](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="f7b28-410">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="f7b28-411">Örtük null yapılabilir dönüşümler ([örtük Nullable dönüşümler](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="f7b28-411">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="f7b28-412">Örtük başvuru dönüştürmeleri ([örtük başvuru dönüştürmeleri](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="f7b28-412">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="f7b28-413">Paketleme dönüştürmeleri ([kutulama dönüştürmeleri](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="f7b28-413">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="f7b28-414">Örtük sabit ifade dönüştürmeleri ([örtük dinamik dönüştürmeler](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="f7b28-414">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="f7b28-415">Tür parametreleri içeren örtük dönüştürmeler ([tür parametreleri Içeren örtük dönüştürmeler](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="f7b28-415">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="f7b28-416">Standart örtük dönüştürmeler özellikle Kullanıcı tanımlı örtük dönüştürmeleri hariç tutar.</span><span class="sxs-lookup"><span data-stu-id="f7b28-416">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="f7b28-417">Standart açık dönüşümler</span><span class="sxs-lookup"><span data-stu-id="f7b28-417">Standard explicit conversions</span></span>

<span data-ttu-id="f7b28-418">Standart açık dönüştürmeler tüm standart örtük dönüştürmelerdir ve ters bir standart örtük dönüştürmenin bulunduğu açık dönüştürmelerin alt kümesidir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-418">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="f7b28-419">Diğer bir deyişle, bir tür `B`türüne standart bir örtük `A` dönüştürme varsa, tür `A` türünden `B` türüne ve `B` tür `A`türüne standart bir açık dönüştürme bulunur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-419">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="f7b28-420">Kullanıcı tanımlı dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-420">User-defined conversions</span></span>

<span data-ttu-id="f7b28-421">C#önceden tanımlanmış örtük ve açık dönüştürmelerin ***Kullanıcı tanımlı dönüşümlerde***artırılmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-421">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="f7b28-422">Kullanıcı tanımlı dönüştürmeler, sınıf ve yapı türlerinde dönüştürme işleçleri ([dönüştürme işleçleri](classes.md#conversion-operators)) bildirerek ortaya çıkartılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-422">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="f7b28-423">İzin verilen Kullanıcı tanımlı dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="f7b28-423">Permitted user-defined conversions</span></span>

<span data-ttu-id="f7b28-424">C#yalnızca belirli kullanıcı tanımlı dönüştürmelerin bildirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-424">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="f7b28-425">Özellikle, zaten varolan bir örtük veya açık dönüştürmeyi yeniden tanımlamak mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-425">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="f7b28-426">Belirli bir kaynak türü `S` ve hedef türü `T`, `S` veya `T` null yapılabilir türlerse, `S0` ve `T0` temel türlerine başvurmasına izin verir, aksi takdirde `S0` ve `T0` sırasıyla `S` ve `T` eşittir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-426">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="f7b28-427">Bir sınıf veya yapının bir kaynak türü `S` bir hedef türüne dönüştürme bildirmesine izin verilir `T` yalnızca aşağıdakilerin tümü doğru ise geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-427">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="f7b28-428">`S0` ve `T0` farklı türlerdir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-428">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="f7b28-429">`S0` ya da `T0`, işleç bildiriminin gerçekleştiği sınıf veya yapı türüdür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-429">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="f7b28-430">Ne `S0` ne de `T0` bir *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="f7b28-430">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="f7b28-431">Kullanıcı tanımlı dönüştürmeler hariç olmak üzere, `S` `T` veya `T` ' den `S`' e kadar bir dönüştürme yok.</span><span class="sxs-lookup"><span data-stu-id="f7b28-431">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="f7b28-432">Kullanıcı tanımlı dönüştürmeler için uygulanan kısıtlamalar, [dönüştürme işleçlerinde](classes.md#conversion-operators)daha ayrıntılı bir şekilde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-432">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="f7b28-433">Yükseltilmemiş dönüştürme işleçleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-433">Lifted conversion operators</span></span>

<span data-ttu-id="f7b28-434">Null yapılamayan bir değer türü `S`, null olamayan bir değer türü `T`dönüştüren bir Kullanıcı tanımlı dönüştürme işleci verildiğinde, `S?` ' den `T?`dönüştüren bir ***yükseltilmemiş dönüştürme işleci*** vardır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-434">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="f7b28-435">Bu yükseltilmemiş dönüştürme işleci, `S?` ' den `S` ' den `T` ' a bir kaydırma gerçekleştirerek, null değerli `T?`doğrudan bir null değerli `S?` dönüştürülebilinerek, `T` `S` ' dan `T?`' a bir sarmalama uygular.</span><span class="sxs-lookup"><span data-stu-id="f7b28-435">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="f7b28-436">Bir yükseltilmemiş dönüştürme işleci, temel aldığı Kullanıcı tanımlı dönüştürme işleci ile aynı örtük veya açık sınıflandırmasına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-436">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="f7b28-437">"Kullanıcı tanımlı dönüştürme" terimi hem Kullanıcı tanımlı hem de yükseltilmemiş dönüştürme işleçlerinin kullanımı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-437">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="f7b28-438">Kullanıcı tanımlı dönüştürmeler değerlendirmesi</span><span class="sxs-lookup"><span data-stu-id="f7b28-438">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="f7b28-439">Kullanıcı tanımlı dönüştürme, ***kaynak türü***olarak adlandırılan türünden bir değeri, ***hedef türü***olarak adlandırılan başka bir türe dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-439">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="f7b28-440">Belirli bir kaynak ve hedef türleri için ***en özel*** Kullanıcı tanımlı dönüştürme işlecini bulmada Kullanıcı tanımlı dönüştürme merkezlerinin değerlendirmesi.</span><span class="sxs-lookup"><span data-stu-id="f7b28-440">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="f7b28-441">Bu belirleme birkaç adımda bozulur:</span><span class="sxs-lookup"><span data-stu-id="f7b28-441">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="f7b28-442">Kullanıcı tanımlı dönüştürme işleçlerinin kabul edileceği sınıfların ve yapıların kümesini bulma.</span><span class="sxs-lookup"><span data-stu-id="f7b28-442">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="f7b28-443">Bu küme, kaynak türünden ve temel sınıflarından ve hedef türünden ve temel sınıflarından oluşur (yalnızca sınıfların ve yapıların Kullanıcı tanımlı işleçleri bildirebilme ve sınıf olmayan türlerin temel sınıfları olmadığı örtük varsayımlar ile).</span><span class="sxs-lookup"><span data-stu-id="f7b28-443">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="f7b28-444">Bu adımın amaçları doğrultusunda, kaynak veya hedef tür bir *nullable_type*ise bunun yerine temel alınan türü kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-444">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="f7b28-445">Bu tür kümesinden, hangi kullanıcı tanımlı ve yükseltilmemiş dönüştürme işleçlerinin geçerli olduğunu belirlemek.</span><span class="sxs-lookup"><span data-stu-id="f7b28-445">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="f7b28-446">Bir dönüştürme işlecinin geçerli olması için, kaynak türünden işlecin işlenen türüne Standart dönüştürme ([Standart dönüşümler](conversions.md#standard-conversions)) gerçekleştirmek mümkün olmalıdır ve işlecin sonuç türünden hedef türüne standart bir dönüştürme gerçekleştirmek mümkün olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-446">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="f7b28-447">Geçerli Kullanıcı tanımlı işleçler kümesinden, hangi işlecin kesin olarak en belirgin olduğunu belirleme.</span><span class="sxs-lookup"><span data-stu-id="f7b28-447">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="f7b28-448">Genel koşullarda, en özel işleç, işlenen türü kaynak türüne "en yakın" olan ve sonuç türü hedef türüne "en yakın" olan işleçtir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-448">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="f7b28-449">Kullanıcı tanımlı dönüştürme işleçleri yükseltilmemiş dönüştürme işleçleri üzerinden tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-449">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="f7b28-450">En belirli kullanıcı tanımlı dönüştürme işlecini oluşturmaya yönelik kuralların tam kuralları aşağıdaki bölümlerde tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-450">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="f7b28-451">En çok belirli bir Kullanıcı tanımlı dönüştürme işleci tanımlandıktan sonra, Kullanıcı tanımlı dönüştürmenin gerçek yürütmesi üç adımdan oluşur:</span><span class="sxs-lookup"><span data-stu-id="f7b28-451">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="f7b28-452">İlk olarak, gerekirse, kaynak türünden Kullanıcı tanımlı veya yükseltilmemiş dönüştürme işlecinin işlenen türüne standart bir dönüştürme işlemi gerçekleştiriliyor.</span><span class="sxs-lookup"><span data-stu-id="f7b28-452">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="f7b28-453">Sonra, dönüştürmeyi gerçekleştirmek için Kullanıcı tanımlı veya yükseltilmemiş dönüştürme işlecini çağırma.</span><span class="sxs-lookup"><span data-stu-id="f7b28-453">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="f7b28-454">Son olarak, gerekirse Kullanıcı tanımlı veya yükseltilmemiş dönüştürme işlecinin sonuç türünden hedef türüne standart bir dönüştürme işlemi gerçekleştiriliyor.</span><span class="sxs-lookup"><span data-stu-id="f7b28-454">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="f7b28-455">Kullanıcı tanımlı bir dönüştürmenin değerlendirmesi hiçbir şekilde birden fazla Kullanıcı tanımlı veya yükseltilmemiş dönüştürme işleci içerir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-455">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="f7b28-456">Diğer bir deyişle `S` türünden `T` türüne dönüştürme, önce `S` 'den `X` 'e Kullanıcı tanımlı bir dönüştürme yürütmez ve ardından `X` 'den `T`'e Kullanıcı tanımlı bir dönüştürme yürütmeyecektir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-456">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="f7b28-457">Aşağıdaki bölümlerde Kullanıcı tanımlı örtük veya açık dönüşümler değerlendirmesinin tam tanımları verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-457">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="f7b28-458">Tanımlar aşağıdaki terimleri kullanır:</span><span class="sxs-lookup"><span data-stu-id="f7b28-458">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="f7b28-459">Bir tür `B`bir türden standart örtük dönüştürme ([Standart örtük dönüştürmeler](conversions.md#standard-implicit-conversions)) varsa ve ne `A` ne de `B` *interface_type*`A`, ***`A` `B`olarak*** kabul edilir ve ***`B` `A`.***</span><span class="sxs-lookup"><span data-stu-id="f7b28-459">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="f7b28-460">Bir tür kümesindeki ***en kapsamlı tür*** , küme içindeki diğer tüm türleri kapsayan tek türdür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-460">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="f7b28-461">Tek bir tür diğer tüm türleri kapsadığı takdirde, küme en fazla kapsayan türe sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-461">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="f7b28-462">Daha sezgisel koşullarda, en çok kapsayan tür, küme içindeki "en büyük" türdür — diğer türlerin her birinin örtük olarak dönüştürülebileceği bir tür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-462">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="f7b28-463">Bir tür kümesindeki ***en kapsamlı tür*** , küme içindeki tüm diğer türler tarafından dahil edilen tek türdür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-463">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="f7b28-464">Tüm diğer türler tarafından tek bir tür yoksa, küme, en çok kullanılan türe sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-464">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="f7b28-465">Daha sezgisel koşullarda, en kapsamlı tür, küme içindeki "en küçük" türüdür ve örtülü olarak diğer türlerin her birine dönüştürülebilirler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-465">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="f7b28-466">Kullanıcı tanımlı örtük dönüştürmeleri işleme</span><span class="sxs-lookup"><span data-stu-id="f7b28-466">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="f7b28-467">`S` türünden `T` türüne Kullanıcı tanımlı örtük dönüştürme şu şekilde işlenir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-467">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="f7b28-468">`S0` ve `T0`türleri belirlenir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-468">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="f7b28-469">`S` veya `T` null yapılabilir türlerse, `S0` ve `T0` temel alınan türlerdir, aksi takdirde `S0` ve `T0` sırasıyla `S` ve `T` eşittir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-469">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="f7b28-470">Kullanıcı tanımlı dönüştürme işleçlerinin kabul edileceği `D`türü kümesini bulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-470">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="f7b28-471">Bu küme `S0` (`S0` bir sınıf veya yapı ise), `S0` temel sınıfları (`S0` bir sınıfsa) ve `T0` (`T0` bir sınıf veya yapı ise) oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-471">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="f7b28-472">Geçerli Kullanıcı tanımlı ve yükseltilmemiş dönüştürme işleçleri kümesini bulun `U`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-472">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="f7b28-473">Bu küme, Kullanıcı tanımlı ve yükseltilmemiş örtük dönüştürme işleçlerinden oluşur ve bir tür kapsayan `S` `T`tarafından dahil edilen bir türe dönüşüm olan `D`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-473">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="f7b28-474">`U` boş ise, dönüştürme tanımsız olur ve derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-474">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-475">`U`işleçleri `SX`en çok belirli kaynak türünü bulun:</span><span class="sxs-lookup"><span data-stu-id="f7b28-475">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="f7b28-476">`U` ' deki işleçlerden herhangi biri `S`' den dönüştürürseniz `SX` `S`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-476">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="f7b28-477">Aksi takdirde `SX`, `U`operatörlerinin Birleşik kaynak türleri kümesindeki en kapsamlı türdür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-477">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="f7b28-478">Tam olarak en kapsamlı bir tür bulunamazsa, dönüştürme belirsizdir ve derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-478">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-479">`U`işleçleri `TX`en çok belirli hedef türünü bulun:</span><span class="sxs-lookup"><span data-stu-id="f7b28-479">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="f7b28-480">`U` ' deki işleçlerden herhangi biri `T`' e dönüştürürsünüz `TX` `T`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-480">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="f7b28-481">Aksi takdirde `TX`, `U`operatörlerinin Birleşik hedef türleri kümesindeki en kapsamlı bir türdür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-481">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="f7b28-482">Tam olarak en kapsamlı bir tür bulunamazsa, dönüştürme belirsizdir ve derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-482">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-483">En belirli dönüştürme işlecini bulun:</span><span class="sxs-lookup"><span data-stu-id="f7b28-483">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="f7b28-484">`U`, `SX` ' ten `TX`dönüştürdüğü tam olarak bir Kullanıcı tanımlı dönüştürme işleci içeriyorsa, bu, en belirli dönüştürme işleçtir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-484">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="f7b28-485">Aksi takdirde, `U` `SX` ' ten `TX`dönüştüren tam olarak bir yükseltilmemiş dönüştürme işleci içeriyorsa, bu, en belirli dönüştürme işleçtir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-485">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="f7b28-486">Aksi takdirde, dönüştürme belirsizdir ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-486">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-487">Son olarak, dönüştürmeyi uygulayın:</span><span class="sxs-lookup"><span data-stu-id="f7b28-487">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="f7b28-488">`S` `SX`değilse, `S` 'den `SX` 'e standart bir örtük dönüşüm yapılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-488">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="f7b28-489">En özel dönüştürme işleci, `SX` ' den `TX`dönüştürmek için çağrılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-489">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="f7b28-490">`TX` `T`değilse, `TX` 'den `T` 'e standart bir örtük dönüşüm yapılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-490">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="f7b28-491">Kullanıcı tanımlı Açık dönüştürmeleri işleme</span><span class="sxs-lookup"><span data-stu-id="f7b28-491">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="f7b28-492">`S` türünden `T` türüne bir Kullanıcı tanımlı açık dönüştürme aşağıdaki şekilde işlenir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-492">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="f7b28-493">`S0` ve `T0`türleri belirlenir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-493">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="f7b28-494">`S` veya `T` null yapılabilir türlerse, `S0` ve `T0` temel alınan türlerdir, aksi takdirde `S0` ve `T0` sırasıyla `S` ve `T` eşittir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-494">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="f7b28-495">Kullanıcı tanımlı dönüştürme işleçlerinin kabul edileceği `D`türü kümesini bulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-495">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="f7b28-496">Bu küme `S0` oluşur (`S0` bir sınıf veya yapı ise), `S0` temel sınıfları (`S0` bir sınıfsa), `T0` (`T0` bir sınıf veya yapı ise) ve temel sınıfları (`T0` bir sınıfsa) oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-496">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="f7b28-497">Geçerli Kullanıcı tanımlı ve yükseltilmemiş dönüştürme işleçleri kümesini bulun `U`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-497">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="f7b28-498">Bu küme, `T`tarafından dahil edilen veya dahil edilen bir tür `S` tarafından dahil edilen veya dahil edilen bir türden veya dahil edilen bir tür tarafından tanımlanan bir türden veya dahil olmak üzere `D`, Kullanıcı tanımlı ve yükseltilmemiş örtük veya açık dönüştürme işleçlerinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-498">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="f7b28-499">`U` boş ise, dönüştürme tanımsız olur ve derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-499">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-500">`U`işleçleri `SX`en çok belirli kaynak türünü bulun:</span><span class="sxs-lookup"><span data-stu-id="f7b28-500">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="f7b28-501">`U` ' deki işleçlerden herhangi biri `S`' den dönüştürürseniz `SX` `S`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-501">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="f7b28-502">Aksi takdirde, `U` ' deki işleçlerden herhangi biri `S`çevreleyen türlerden dönüşütürse `SX`, bu operatörlerin Birleşik kaynak türleri kümesindeki en kapsamlı türdür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-502">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="f7b28-503">En çok kullanılan tür bulunamıyorsa, dönüştürme belirsizdir ve derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-503">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="f7b28-504">Aksi takdirde `SX`, `U`operatörlerinin Birleşik kaynak türleri kümesindeki en kapsamlı bir türdür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-504">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="f7b28-505">Tam olarak en kapsamlı bir tür bulunamazsa, dönüştürme belirsizdir ve derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-505">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-506">`U`işleçleri `TX`en çok belirli hedef türünü bulun:</span><span class="sxs-lookup"><span data-stu-id="f7b28-506">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="f7b28-507">`U` ' deki işleçlerden herhangi biri `T`' e dönüştürürsünüz `TX` `T`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-507">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="f7b28-508">Aksi takdirde, `U` içindeki işleçlerden herhangi biri `T`tarafından dahil edilen türlere dönüşütürse `TX`, bu operatörlerin birleştirilmiş hedef türleri kümesindeki en kapsamlı bir tür olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-508">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="f7b28-509">Tam olarak en kapsamlı bir tür bulunamazsa, dönüştürme belirsizdir ve derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-509">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="f7b28-510">Aksi takdirde `TX`, `U`operatörlerin Birleşik hedef türleri kümesindeki en kapsamlı türdür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-510">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="f7b28-511">En çok kullanılan tür bulunamıyorsa, dönüştürme belirsizdir ve derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-511">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-512">En belirli dönüştürme işlecini bulun:</span><span class="sxs-lookup"><span data-stu-id="f7b28-512">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="f7b28-513">`U`, `SX` ' ten `TX`dönüştürdüğü tam olarak bir Kullanıcı tanımlı dönüştürme işleci içeriyorsa, bu, en belirli dönüştürme işleçtir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-513">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="f7b28-514">Aksi takdirde, `U` `SX` ' ten `TX`dönüştüren tam olarak bir yükseltilmemiş dönüştürme işleci içeriyorsa, bu, en belirli dönüştürme işleçtir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-514">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="f7b28-515">Aksi takdirde, dönüştürme belirsizdir ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-515">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-516">Son olarak, dönüştürmeyi uygulayın:</span><span class="sxs-lookup"><span data-stu-id="f7b28-516">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="f7b28-517">`S` `SX`değilse, `S` 'den `SX` 'e standart bir açık dönüştürme yapılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-517">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="f7b28-518">En özel kullanıcı tanımlı dönüştürme işleci `SX` `TX`' den ' a dönüştürmek için çağrılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-518">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="f7b28-519">`TX` `T`değilse, `TX` 'den `T` 'e standart bir açık dönüştürme yapılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-519">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="f7b28-520">Anonim işlev dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-520">Anonymous function conversions</span></span>

<span data-ttu-id="f7b28-521">Bir *anonymous_method_expression* veya *lambda_expression* anonim Işlev olarak sınıflandırılır ([anonim işlev ifadeleri](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="f7b28-521">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="f7b28-522">İfade bir türe sahip değil, ancak örtülü olarak uyumlu bir temsilci türüne veya ifade ağacı türüne dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-522">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="f7b28-523">Özellikle, anonim bir işlev `F`, sağlanmış `D` bir temsilci türü ile uyumludur:</span><span class="sxs-lookup"><span data-stu-id="f7b28-523">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="f7b28-524">`F` bir *anonymous_function_signature*içeriyorsa `D` ve `F` aynı sayıda parametreye sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-524">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="f7b28-525">`F` bir *anonymous_function_signature*içermiyorsa, `D` hiçbir parametresi `out` parametre değiştiricisine sahip olmadığı sürece `D` herhangi bir türde sıfır veya daha fazla parametreye sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-525">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="f7b28-526">`F` açıkça belirlenmiş bir parametre listesi varsa, `D` her bir parametre, `F`karşılık gelen parametresiyle aynı tür ve değiştiricilere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-526">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="f7b28-527">`F` örtük olarak yazılmış bir parametre listesine sahipse, `D` `ref` veya `out` parametreye sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-527">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="f7b28-528">`F` gövdesi bir ifadesiyse ve `D` bir `void` dönüş türüne sahipse veya `F` zaman uyumsuz ise ve `D` dönüş türü `Task`ise, *her bir `F`* parametresi `D`karşılık gelen parametrenin türüne verildiğinde, `F` gövdesi statement_expression ([ifade deyimleri](statements.md#expression-statements)) olarak izin verilen geçerli bir Ifadedir (WRT [ifadeleri](expressions.md)).</span><span class="sxs-lookup"><span data-stu-id="f7b28-528">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="f7b28-529">`F` gövdesi bir deyim bloğu ise ve `D` bir `void` dönüş türüne sahipse veya `F` zaman uyumsuz ise ve `D` dönüş türü `Task`ise, her bir `F` parametresi `D`ilgili parametresinin türü verildiğinde, `F` gövdesi, hiçbir `return` deyiminin bir ifadeyi belirttiği geçerli bir deyim bloğu (WRT [blokları](statements.md#blocks)) olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-529">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="f7b28-530">`F` gövdesi bir ifade ise *ve `F` zaman* uyumsuz ve `D` void olmayan bir dönüş türü `T`, *ya* da `F` zaman uyumsuz ve `D` bir dönüş türüne sahip `Task<T>`, `F` her bir parametresi `D`için örtük olarak dönüştürülebilir geçerli bir Ifadedir (WRT [ifadeleri](expressions.md)).</span><span class="sxs-lookup"><span data-stu-id="f7b28-530">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="f7b28-531">`F` gövdesi bir ifade bloğudur *ve `F` zaman uyumsuz ve `D`* void olmayan bir dönüş türüne sahip `T`, *ya* da `F` zaman uyumsuz ve `D` bir dönüş türüne sahip `Task<T>`, her bir `F` parametresi `D`karşılık gelen parametrenin türü verildiğinde, `F` gövdesi, her `return` deyiminin `T`örtük olarak dönüştürülebilir bir ifadeyi belirttiği, erişilebilir olmayan bir uç noktası olan geçerli bir deyim bloğu (WRT [blokları](statements.md#blocks)).</span><span class="sxs-lookup"><span data-stu-id="f7b28-531">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="f7b28-532">Bu bölümde, breçekimi için, `Task` ve `Task<T>` ([zaman uyumsuz işlevler](classes.md#async-functions)) görev türleri için kısa form kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-532">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="f7b28-533">Bir lambda ifadesi `F`, `F` temsilci `D`türüyle uyumluysa `Expression<D>` bir ifade ağacı türü ile uyumludur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-533">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="f7b28-534">Bu, anonim metotlar için, yalnızca Lambda ifadelerinde uygulanmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f7b28-534">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="f7b28-535">Bazı lambda ifadeleri ifade ağacı türlerine dönüştürülemez: dönüştürme *mevcut*olsa bile, derleme zamanında başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-535">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="f7b28-536">Lambda ifadesi ise bu durum budur:</span><span class="sxs-lookup"><span data-stu-id="f7b28-536">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="f7b28-537">Bir *blok* gövdesine sahiptir</span><span class="sxs-lookup"><span data-stu-id="f7b28-537">Has a *block* body</span></span>
*  <span data-ttu-id="f7b28-538">Basit veya bileşik atama işleçleri içerir</span><span class="sxs-lookup"><span data-stu-id="f7b28-538">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="f7b28-539">Dinamik olarak bağlı bir ifade içerir</span><span class="sxs-lookup"><span data-stu-id="f7b28-539">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="f7b28-540">Zaman uyumsuz</span><span class="sxs-lookup"><span data-stu-id="f7b28-540">Is async</span></span>

<span data-ttu-id="f7b28-541">Aşağıdaki örnekler, `A` türünde bir bağımsız değişken alan ve `R`türünde bir değer döndüren bir işlevi temsil eden `Func<A,R>` genel bir temsilci türü kullanır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-541">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="f7b28-542">Atamalarında</span><span class="sxs-lookup"><span data-stu-id="f7b28-542">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="f7b28-543">Her adsız işlevin parametre ve dönüş türleri, adsız işlevin atandığı değişkenin türünden belirlenir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-543">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="f7b28-544">İlk atama, anonim işlevi `Func<int,int>` temsilci türüne başarıyla dönüştürür çünkü `x` tür `int`verildiğinde, `x+1` örtük olarak `int`türüne dönüştürülebilir geçerli bir ifadedir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-544">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="f7b28-545">Benzer şekilde, `x+1` (`int`) sonucu `double`türüne örtülü olarak dönüştürülebilir olduğundan, ikinci atama anonim işlevi `Func<int,double>` temsilci türüne başarıyla dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-545">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="f7b28-546">Ancak, üçüncü atama bir derleme zamanı hatasıdır çünkü `x` `double`türü verildiğinde `double``x+1` sonucu, `int`türüne örtülü olarak dönüştürülebilir değildir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-546">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="f7b28-547">Dördüncü atama, anonim zaman uyumsuz işlevi `Func<int, Task<int>>` temsilci türüne başarıyla dönüştürür çünkü `x+1` (`int`) sonucu, `Task<int>`görev türü `int` sonuç türüne örtük olarak dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-547">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="f7b28-548">Anonim işlevler aşırı yükleme çözünürlüğünü etkileyebilir ve tür çıkarımı içine katılabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-548">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="f7b28-549">Daha fazla ayrıntı için bkz. [işlev üyeleri](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="f7b28-549">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="f7b28-550">Temsilci türlerine adsız işlev dönüştürmelerini değerlendirme</span><span class="sxs-lookup"><span data-stu-id="f7b28-550">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="f7b28-551">Anonim bir işlevin bir temsilci türüne dönüştürülmesi,, değerlendirme sırasında etkin olan yakalanan dış değişkenlerin adsız işlevine ve (muhtemelen boş) başvuruda bulunduğu bir temsilci örneği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-551">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="f7b28-552">Temsilci çağrıldığında, adsız işlevin gövdesi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-552">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="f7b28-553">Gövdedeki kod, temsilci tarafından başvurulan yakalanan dış değişkenler kümesi kullanılarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-553">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="f7b28-554">Anonim bir işlevden üretilen temsilcinin çağırma listesi tek bir giriş içerir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-554">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="f7b28-555">Temsilcinin tam hedef nesnesi ve Target Yöntemi belirtilmemiş.</span><span class="sxs-lookup"><span data-stu-id="f7b28-555">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="f7b28-556">Özellikle, temsilcinin hedef nesnesinin `null`, kapsayan işlev üyesinin `this` değeri veya başka bir nesne olup olmadığı belirlenmediğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-556">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="f7b28-557">Aynı temsilci türlerine aynı (muhtemelen boş) yakalanan dış değişken örnekleri kümesine sahip anlamsal özdeş anonim işlevlerin dönüştürülmesine izin verilir (ancak gerekli değildir).</span><span class="sxs-lookup"><span data-stu-id="f7b28-557">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="f7b28-558">Aynı bağımsız değişkenlerle aynı etkileri sunan, her durumda, anonim işlevlerin yürütülmesi için, burada anlamsal olarak özdeş terimi kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-558">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="f7b28-559">Bu kural, aşağıdakiler gibi kodun iyileştirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-559">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="f7b28-560">İki anonim işlev temsilcisi aynı (boş) yakalanan dış değişken kümesine sahip olduğundan ve anonim işlevler anlam açısından özdeş olduğundan, derleyicinin temsilcilerin aynı hedef yönteme başvurmasına izin verilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-560">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="f7b28-561">Aslında, derleyicinin hem anonim işlev ifadelerinden çok aynı temsilci örneğini döndürmesine izin verilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-561">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="f7b28-562">İfade ağacı türlerine anonim işlev dönüştürmeleri değerlendirmesi</span><span class="sxs-lookup"><span data-stu-id="f7b28-562">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="f7b28-563">Anonim bir işlevin ifade ağacı türüne dönüştürülmesi bir ifade ağacı ([ifade ağacı türleri](types.md#expression-tree-types)) oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-563">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="f7b28-564">Daha kesin olarak, anonim işlev dönüştürmenin değerlendirmesi, anonim işlevin yapısını temsil eden bir nesne yapısının oluşturulmasına yol açar.</span><span class="sxs-lookup"><span data-stu-id="f7b28-564">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="f7b28-565">İfade ağacının kesin yapısı ve bunu oluşturmak için tam işlem, uygulama tanımlı olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-565">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="f7b28-566">Uygulama örneği</span><span class="sxs-lookup"><span data-stu-id="f7b28-566">Implementation example</span></span>

<span data-ttu-id="f7b28-567">Bu bölümde, anonim işlev dönüştürmelerinden diğer C# yapılar açısından olası bir uygulama açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-567">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="f7b28-568">Burada açıklanan uygulama, Microsoft C# derleyicisi tarafından kullanılan ilkelere dayanır, ancak bu, bir uygulanan uygulamasına sahip değildir ve tek mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-568">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="f7b28-569">Bu belirtim, tam semantiği bu şartların kapsamı dışında olduğu için yalnızca Dönüştürmelere ifade ağaçlarına değinmektedir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-569">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="f7b28-570">Bu bölümün geri kalanında, farklı özelliklere sahip anonim işlevler içeren çeşitli kod örnekleri verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-570">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="f7b28-571">Her örnek için, yalnızca diğer C# yapıları kullanan koda karşılık gelen bir çeviri sağlanır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-571">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="f7b28-572">Örneklerde tanımlayıcı `D`, aşağıdaki temsilci türünü temsil eden kabul edilir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-572">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="f7b28-573">Anonim bir işlevin en basit biçimi, dış değişken içermeyen bir işlevdir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-573">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="f7b28-574">Bu, anonim işlevin kodunun yerleştirildiği bir derleyicinin ürettiği statik metoda başvuran bir temsilci örneklemesine çevrilebilir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-574">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="f7b28-575">Aşağıdaki örnekte, anonim işlev `this`örnek üyelerine başvurur:</span><span class="sxs-lookup"><span data-stu-id="f7b28-575">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="f7b28-576">Bu, anonim işlevin kodunu içeren bir derleyici tarafından oluşturulan örnek metoduna çevrilebilir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-576">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="f7b28-577">Bu örnekte, anonim işlev yerel bir değişken yakalar:</span><span class="sxs-lookup"><span data-stu-id="f7b28-577">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="f7b28-578">Yerel değişkenin kullanım ömrü artık en azından adsız işlev temsilcisinin kullanım ömrüne kadar genişletilmelidir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-578">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="f7b28-579">Bu, yerel değişken derleyicinin ürettiği bir sınıfın bir alanına "barındırıdırarak" elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-579">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="f7b28-580">Yerel değişkenin ([yerel değişkenlerin örneklenmesi](expressions.md#instantiation-of-local-variables)) örneklenmesi, ardından derleyici tarafından oluşturulan sınıfın bir örneğini oluşturmaya karşılık gelir ve yerel değişkene erişmek, derleyici tarafından oluşturulan sınıfın örneğindeki bir alana erişmeye karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-580">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="f7b28-581">Ayrıca, anonim işlev derleyicinin ürettiği sınıfının örnek yöntemi olur:</span><span class="sxs-lookup"><span data-stu-id="f7b28-581">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="f7b28-582">Son olarak, aşağıdaki anonim işlev `this` ve farklı yaşam süreleri olan iki yerel değişken yakalar:</span><span class="sxs-lookup"><span data-stu-id="f7b28-582">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="f7b28-583">Burada, yerellerin yakalandığı her bir ekstre bloğu için, farklı bloklara ait yerellerin bağımsız yaşam sürelerinin bulunduğu bir derleyici tarafından oluşturulan bir sınıf oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-583">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="f7b28-584">`__Locals2`örneği, iç ifade bloğunun derleyici tarafından üretilen sınıfı, `z` yerel değişkeni ve bir `__Locals1`örneğine başvuran bir alanı içerir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-584">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="f7b28-585">Bir `__Locals1`örneği, dış ifade bloğu için derleyici tarafından oluşturulan sınıf, `y` yerel değişkeni ve kapsayan işlev üyesinin `this` başvuruda bulunan bir alanı içerir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-585">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="f7b28-586">Bu veri yapıları ile, bir `__Local2`örneği aracılığıyla yakalanan tüm dış değişkenlere ulaşmak mümkündür ve anonim işlevin kodu bu sınıfın örnek yöntemi olarak uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-586">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="f7b28-587">Yerel değişkenleri yakalamak için burada uygulanan teknik, anonim işlevler ifade ağaçlarına dönüştürülürken de kullanılabilir: derleyicinin ürettiği nesneler için başvurular ifade ağacında depolanabilir ve yerel değişkenlere erişim şu olabilir: Bu nesnelerde alan erişimi olarak gösterilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-587">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="f7b28-588">Bu yaklaşımın avantajı, "yükseltilmemiş" yerel değişkenlerinin temsilciler ve ifade ağaçları arasında paylaşılmasını olanaklı kılar.</span><span class="sxs-lookup"><span data-stu-id="f7b28-588">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="f7b28-589">Yöntem grubu dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="f7b28-589">Method group conversions</span></span>

<span data-ttu-id="f7b28-590">Bir yöntem grubundan ([örtük dönüştürmeler](conversions.md#implicit-conversions)), uyumlu bir temsilci türüne ([ifade sınıflandırmaları](expressions.md#expression-classifications)) sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-590">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="f7b28-591">Bir temsilci türü `D` ve bir yöntem grubu olarak sınıflandırılan bir ifade `E` verildiğinde, `E`, normal biçimde (uygulanabilir işlev üyesi), aşağıdaki gibi `D`parametre türleri ve değiştiriciler kullanılarak oluşturulan bir bağımsız değişken listesine ([geçerli işlev üyesi](expressions.md#applicable-function-member)) göre oluşturulan bir bağımsız değişken listesine sahip olan bir bağımsız değişken listesine `D` `E` bir örtük dönüştürme bulunur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-591">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="f7b28-592">Bir yöntem grubundan dönüştürmenin derleme zamanı uygulaması, `D` bir temsilci türüne `E`, aşağıda açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-592">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="f7b28-593">`E` 'den `D` örtük dönüştürmenin mevcut olması, dönüştürmenin derleme zamanı uygulamasının hata olmadan başarılı olacağını garanti etmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-593">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="f7b28-594">Tek bir yöntem `M`, aşağıdaki değişikliklerle birlikte, `E(A)`form bir yöntem çağrısına ([Yöntem etkinleştirmeleri](expressions.md#method-invocations)) karşılık gelen seçilir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-594">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="f7b28-595">`A` bağımsız değişken listesi, her biri bir değişken olarak sınıflandırılan ve `D`*formal_parameter_list* karşılık gelen parametrenin türü ve değiştiricisi (`ref` veya `out`) olan ifadelerin bir listesidir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-595">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="f7b28-596">Göz önünde bulundurulması gereken aday yöntemleri yalnızca kendi normal biçimlerinde ([uygulanabilir işlev üyesi](expressions.md#applicable-function-member)) uygulanabilen ve yalnızca genişletilmiş biçimlerinde geçerli olan yöntemlerdir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-596">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="f7b28-597">[Yöntem etkinleştirmeleri](expressions.md#method-invocations) algoritması bir hata üretirse, derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-597">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="f7b28-598">Aksi takdirde, algoritma `D` aynı sayıda parametreye sahip `M` tek bir en iyi yöntem üretir ve dönüştürme var olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-598">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="f7b28-599">Seçilen yöntem `M`, temsilci türü `D`uyumlu olmalıdır ([temsilci uyumluluğu](delegates.md#delegate-compatibility)) veya aksi halde bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-599">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="f7b28-600">Seçilen `M` Yöntem bir örnek yöntemi ise, `E` ile ilişkili örnek ifadesi temsilcinin hedef nesnesini belirler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-600">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="f7b28-601">Seçili Yöntem, bir örnek ifadesinde üye erişimi aracılığıyla belirtilen bir genişletme yöntemi ise, bu örnek ifadesi temsilcinin hedef nesnesini belirler.</span><span class="sxs-lookup"><span data-stu-id="f7b28-601">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="f7b28-602">Dönüştürmenin sonucu `D`türünde bir değerdir, yani seçili yönteme ve hedef nesneye başvuran yeni oluşturulmuş bir temsilcisidir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-602">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="f7b28-603">Bu işlemin bir uzantı yöntemine bir temsilci oluşturulmasına yol açabileceğini unutmayın. [Yöntem etkinleştirmeleri](expressions.md#method-invocations) algoritması bir örnek yöntemi bulamazsa, ancak `E(A)` bir uzantı yöntemi çağırma ([genişletme yöntemi etkinleştirmeleri](expressions.md#extension-method-invocations)) olarak çağırma işlemini işlerken başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-603">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="f7b28-604">Bu nedenle oluşturulan bir temsilci, Uzantı yönteminin yanı sıra ilk bağımsız değişkenini de yakalar.</span><span class="sxs-lookup"><span data-stu-id="f7b28-604">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="f7b28-605">Aşağıdaki örnekte, Yöntem grubu dönüştürmeleri gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-605">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="f7b28-606">`d1` atama, `F` Yöntem grubunu `D1`türünde bir değere örtülü olarak dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="f7b28-606">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="f7b28-607">`d2` atama, daha az türetilmiş (değişken karşıtı) parametre türleri ve daha türetilmiş (covaryant) dönüş türü olan bir yönteme bir temsilci oluşturmak için nasıl mümkün olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-607">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="f7b28-608">`d3` atama, yöntemin geçerli olmadığı durumlarda dönüştürmenin nasıl mevcut olmadığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-608">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="f7b28-609">`d4` atama, yönteminin normal biçiminde nasıl geçerli olması gerektiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-609">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="f7b28-610">`d5` atama, temsilci ve yöntemin dönüş türlerinin ve yalnızca başvuru türleri için farklı olmasına izin verildiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-610">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="f7b28-611">Diğer tüm örtük ve açık dönüşümlerde olduğu gibi, atama işleci açıkça bir yöntem grubu dönüştürmesi gerçekleştirmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-611">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="f7b28-612">Bu nedenle örnek</span><span class="sxs-lookup"><span data-stu-id="f7b28-612">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="f7b28-613">Bunun yerine yazılabilir</span><span class="sxs-lookup"><span data-stu-id="f7b28-613">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="f7b28-614">Yöntem grupları aşırı yükleme çözümlemesini etkileyebilir ve tür çıkarımı içine katılabilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-614">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="f7b28-615">Daha fazla ayrıntı için bkz. [işlev üyeleri](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="f7b28-615">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="f7b28-616">Bir yöntem grubu dönüşümünün çalışma zamanı değerlendirmesi aşağıdaki gibi devam eder:</span><span class="sxs-lookup"><span data-stu-id="f7b28-616">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="f7b28-617">Derleme zamanında seçilen yöntem bir örnek yöntemi ise veya bir örnek yöntemi olarak erişilen bir genişletme yöntemi ise, temsilcinin hedef nesnesi `E`ilişkili örnek ifadeden belirlenir:</span><span class="sxs-lookup"><span data-stu-id="f7b28-617">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="f7b28-618">Örnek ifadesi değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-618">The instance expression is evaluated.</span></span> <span data-ttu-id="f7b28-619">Bu değerlendirme bir özel duruma neden olursa başka bir adım yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-619">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="f7b28-620">Örnek ifadesi bir *reference_type*ise, örnek ifadesi tarafından hesaplanan değer hedef nesne olur.</span><span class="sxs-lookup"><span data-stu-id="f7b28-620">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="f7b28-621">Seçilen yöntem bir örnek yöntemi ise ve hedef nesne `null`, bir `System.NullReferenceException` oluşturulur ve başka bir adım yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-621">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="f7b28-622">Örnek ifadesi bir *value_type*ise, değeri bir nesneye dönüştürmek için bir paketleme Işlemi ([kutulama dönüştürmeleri](types.md#boxing-conversions)) gerçekleştirilir ve bu nesne hedef nesne haline gelir.</span><span class="sxs-lookup"><span data-stu-id="f7b28-622">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="f7b28-623">Aksi takdirde, seçilen yöntem bir statik yöntem çağrısının parçasıdır ve temsilcinin hedef nesnesi `null`.</span><span class="sxs-lookup"><span data-stu-id="f7b28-623">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="f7b28-624">`D` temsilci türünün yeni bir örneği ayrılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-624">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="f7b28-625">Yeni örneği ayırmak için yeterli kullanılabilir bellek yoksa bir `System.OutOfMemoryException` oluşturulur ve başka bir adım yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="f7b28-625">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="f7b28-626">Yeni temsilci örneği, derleme zamanında belirlenen yönteme ve yukarıda hesaplanan hedef nesneye bir başvuruya sahip bir başvuru ile başlatılır.</span><span class="sxs-lookup"><span data-stu-id="f7b28-626">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
