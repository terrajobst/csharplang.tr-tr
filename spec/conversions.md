# <a name="conversions"></a><span data-ttu-id="07320-101">Dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-101">Conversions</span></span>

<span data-ttu-id="07320-102">A ***dönüştürme*** bir ifadenin belirli bir tür olacak şekilde değerlendirilmesi olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="07320-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="07320-103">Bir dönüştürme, farklı bir türe sahip olarak kabul edilmesi için belirli bir türde bir ifade neden olabilecek ya da bir tür için bir tür olmayan bir ifade neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="07320-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="07320-104">Dönüştürmeleri olabilir ***örtük*** veya ***açık***, ve bu bir açık tür dönüştürme gerekli olup olmadığını belirler.</span><span class="sxs-lookup"><span data-stu-id="07320-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="07320-105">Örneği için tür dönüştürme `int` türüne `long` kapalıdır, bunu ifadeler tür `int` türü örtük olarak davranılıp `long`.</span><span class="sxs-lookup"><span data-stu-id="07320-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="07320-106">Türünden ters dönüştürme `long` türüne `int`, açık olan ve açık bir tür dönüştürme gerekiyor.</span><span class="sxs-lookup"><span data-stu-id="07320-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="07320-107">Bazı dönüştürmeler dil tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="07320-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="07320-108">Programları kendi dönüştürmeler de tanımlayabilir ([kullanıcı tanımlı dönüşümler](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="07320-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="07320-109">Örtük dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-109">Implicit conversions</span></span>

<span data-ttu-id="07320-110">Aşağıdaki dönüştürmeler, örtük dönüştürmelerin sınıflandırılır:</span><span class="sxs-lookup"><span data-stu-id="07320-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="07320-111">Kimlik dönüştürme</span><span class="sxs-lookup"><span data-stu-id="07320-111">Identity conversions</span></span>
*  <span data-ttu-id="07320-112">Örtük sayısal dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="07320-113">Numaralandırma örtük dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="07320-113">Implicit enumeration conversions.</span></span>
*  <span data-ttu-id="07320-114">Boş değer atanabilir örtük dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-114">Implicit nullable conversions</span></span>
*  <span data-ttu-id="07320-115">Null değişmez değer dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="07320-115">Null literal conversions</span></span>
*  <span data-ttu-id="07320-116">Örtük bir başvuru dönüşümleri</span><span class="sxs-lookup"><span data-stu-id="07320-116">Implicit reference conversions</span></span>
*  <span data-ttu-id="07320-117">Kutulama dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-117">Boxing conversions</span></span>
*  <span data-ttu-id="07320-118">Örtük dinamik dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-118">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="07320-119">Örtük sabit ifade dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-119">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="07320-120">Kullanıcı tanımlı örtük dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-120">User-defined implicit conversions</span></span>
*  <span data-ttu-id="07320-121">Anonim işlev dönüştürme</span><span class="sxs-lookup"><span data-stu-id="07320-121">Anonymous function conversions</span></span>
*  <span data-ttu-id="07320-122">Yöntem grubu dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-122">Method group conversions</span></span>

<span data-ttu-id="07320-123">Örtük dönüştürmeleri durumlarda işlevi üye çağrıları dahil olmak üzere çeşitli meydana gelebilir ([derleme zamanı dinamik aşırı yükleme çözünürlüğü denetimi](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast ifadeleri ([Cast ifadeleri](expressions.md#cast-expressions)), ve atamaları ([atama işleçleri](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="07320-123">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="07320-124">Önceden tanımlanmış örtük dönüştürmeler her zaman başarılı ve hiçbir zaman özel durum oluşturulmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="07320-124">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="07320-125">Kullanıcı tanımlı düzgün bir şekilde tasarlanmış örtük dönüştürmeleri bu özellikleri de göstermesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="07320-125">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="07320-126">Türleri dönüştürme amacıyla `object` ve `dynamic` eşdeğer olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="07320-126">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="07320-127">Ancak, dinamik dönüştürmeler ([dinamik örtük dönüştürmelerin](conversions.md#implicit-dynamic-conversions) ve [açık dinamik dönüştürmeler](conversions.md#explicit-dynamic-conversions)) yalnızca türündeki ifadeler için uygulama `dynamic` ([dinamik tür](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="07320-127">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="07320-128">Kimlik dönüştürme</span><span class="sxs-lookup"><span data-stu-id="07320-128">Identity conversion</span></span>

<span data-ttu-id="07320-129">Bir kimlik dönüştürme herhangi bir türü aynı türe dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="07320-129">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="07320-130">Gerekli bir tür zaten olan bir varlık, bu türe dönüştürülebilir olmalıdır söylenebilir, bu dönüşümü yok.</span><span class="sxs-lookup"><span data-stu-id="07320-130">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="07320-131">Nesne ve dinamik eşdeğer kabul edildiği için bir kimlik dönüştürme arasında yoktur `object` ve `dynamic`, aynı olan tüm oluşumlarını değiştirilirken oluşturulan türler arasında `dynamic` ile `object`.</span><span class="sxs-lookup"><span data-stu-id="07320-131">Because object and dynamic are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="07320-132">Örtük sayısal dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-132">Implicit numeric conversions</span></span>

<span data-ttu-id="07320-133">Örtük sayısal dönüşümler verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="07320-133">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="07320-134">Gelen `sbyte` için `short`, `int`, `long`, `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-134">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-135">Gelen `byte` için `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-135">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-136">Gelen `short` için `int`, `long`, `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-136">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-137">Gelen `ushort` için `int`, `uint`, `long`, `ulong`, `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-137">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-138">Gelen `int` için `long`, `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-138">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-139">Gelen `uint` için `long`, `ulong`, `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-139">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-140">Gelen `long` için `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-140">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-141">Gelen `ulong` için `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-141">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-142">Gelen `char` için `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-142">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-143">Gelen `float` için `double`.</span><span class="sxs-lookup"><span data-stu-id="07320-143">From `float` to `double`.</span></span>

<span data-ttu-id="07320-144">Dönüştürmelere `int`, `uint`, `long`, veya `ulong` için `float` ve `long` veya `ulong` için `double` duyarlık kaybına neden ancak hiçbir zaman büyüklük kaybına neden olur.</span><span class="sxs-lookup"><span data-stu-id="07320-144">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="07320-145">Diğer örtük sayısal dönüştürmeler, hiçbir zaman bilgileri kaybedersiniz.</span><span class="sxs-lookup"><span data-stu-id="07320-145">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="07320-146">Herhangi bir örtük dönüştürme vardır `char` türü için değer bir tam sayı türleri için otomatik olarak dönüştürmez `char` türü.</span><span class="sxs-lookup"><span data-stu-id="07320-146">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="07320-147">Numaralandırma örtük dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="07320-147">Implicit enumeration conversions</span></span>

<span data-ttu-id="07320-148">Bir numaralandırma örtük dönüştürme verir *decimal_integer_literal* `0` herhangi dönüştürülecek *enum_type* ve herhangi bir *nullable_type* olan temel alınan türü olan bir *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-148">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="07320-149">İkinci durumda, temel alınan dönüştürerek dönüştürme değerlendirilir *enum_type* ve sonucu sarmalama ([boş değer atanabilir türler](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="07320-149">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="07320-150">Örtük ilişkilendirilmiş dize dönüştürme</span><span class="sxs-lookup"><span data-stu-id="07320-150">Implicit interpolated string conversions</span></span>

<span data-ttu-id="07320-151">Örtük ilişkilendirilmiş dize dönüştürme izinleri bir *interpolated_string_expression* ([Ara değerli dizeler](expressions.md#interpolated-strings)) dönüştürülecek `System.IFormattable` veya `System.FormattableString` (uygulayan `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="07320-151">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="07320-152">Bu dönüştürme uygulandığında bir dize değeri ilişkilendirilmiş dizeden oluşur değil.</span><span class="sxs-lookup"><span data-stu-id="07320-152">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="07320-153">Bunun yerine bir örneğini `System.FormattableString` oluşturulmuş, daha ayrıntılı olarak açıklanan [Ara değerli dizeler](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="07320-153">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="07320-154">Boş değer atanabilir örtük dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-154">Implicit nullable conversions</span></span>

<span data-ttu-id="07320-155">NULL olmayan değer türleri üzerinde çalışması önceden tanımlanmış örtük dönüştürmeleri bu türlerin boş değer atanabilir forms ile de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="07320-155">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="07320-156">Her bir NULL olmayan değer türünden dönüştürme sayısal dönüşümler ve önceden tanımlanmış bir örtük kimlik `S` NULL olmayan bir değer türü için `T`, aşağıdaki boş değer atanabilir örtük dönüştürmeleri vardır:</span><span class="sxs-lookup"><span data-stu-id="07320-156">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="07320-157">Örtük bir dönüştürme `S?` için `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-157">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="07320-158">Örtük bir dönüştürme `S` için `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-158">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="07320-159">Temel alınan bir dönüştürme açık boş değer atanabilir bir dönüştürme değerlendirmesini temel `S` için `T` aşağıdaki gibi çalışır:</span><span class="sxs-lookup"><span data-stu-id="07320-159">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="07320-160">Boş değer atanabilir bir dönüştürme ise `S?` için `T?`:</span><span class="sxs-lookup"><span data-stu-id="07320-160">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="07320-161">Kaynak değeri null ise (`HasValue` özellik değer: false), sonuç türü null değeri `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-161">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="07320-162">Aksi takdirde, dönüştürme bir gelen çözülme olarak değerlendirilir `S?` için `S`, temel alınan dönüştürme işlemi tarafından izlenen `S` için `T`bir sarmalama çizgidir ([boş değer atanabilir türler](types.md#nullable-types)) gelen`T` için `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-162">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="07320-163">Boş değer atanabilir bir dönüştürme ise `S` için `T?`, dönüştürme temel alınan dönüştürme işlemini değerlendirmesinde `S` için `T` diğerine kaydırma ardından `T` için `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-163">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="07320-164">Null değişmez değer dönüştürmeleri</span><span class="sxs-lookup"><span data-stu-id="07320-164">Null literal conversions</span></span>

<span data-ttu-id="07320-165">Öğesinden örtük bir dönüştürme var `null` değişmez değer için boş değer atanabilir bir tür.</span><span class="sxs-lookup"><span data-stu-id="07320-165">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="07320-166">Bu dönüştürme null değerini üretir ([boş değer atanabilir türler](types.md#nullable-types)) belirtilen boş değer atanabilir türde.</span><span class="sxs-lookup"><span data-stu-id="07320-166">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="07320-167">Örtük bir başvuru dönüşümleri</span><span class="sxs-lookup"><span data-stu-id="07320-167">Implicit reference conversions</span></span>

<span data-ttu-id="07320-168">Örtük bir başvuru dönüşümleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="07320-168">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="07320-169">Herhangi *reference_type* için `object` ve `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="07320-169">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="07320-170">Herhangi *class_type* `S` herhangi *class_type* `T`, sağlanan `S` türetilir `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-170">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="07320-171">Herhangi *class_type* `S` herhangi *INTERFACE_TYPE* `T`, sağlanan `S` uygulayan `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-171">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="07320-172">Herhangi *INTERFACE_TYPE* `S` herhangi *INTERFACE_TYPE* `T`, sağlanan `S` türetilir `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-172">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="07320-173">Gelen bir *array_type* `S` bir öğe türü ile `SE` için bir *array_type* `T` bir öğe türü ile `TE`, aşağıdakilerin tümü doğru şunlardır:</span><span class="sxs-lookup"><span data-stu-id="07320-173">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="07320-174">`S` ve `T` yalnızca öğe türleri farklı.</span><span class="sxs-lookup"><span data-stu-id="07320-174">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="07320-175">Diğer bir deyişle, `S` ve `T` aynı sayıda boyuta sahip.</span><span class="sxs-lookup"><span data-stu-id="07320-175">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="07320-176">Her ikisi de `SE` ve `TE` olan *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="07320-176">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="07320-177">Öğesinden örtük bir başvuru dönüştürmesi var `SE` için `TE`.</span><span class="sxs-lookup"><span data-stu-id="07320-177">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="07320-178">Herhangi *array_type* için `System.Array` ve arabirimlerini uygular.</span><span class="sxs-lookup"><span data-stu-id="07320-178">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="07320-179">Bir tek boyutlu dizi türünden `S[]` için `System.Collections.Generic.IList<T>` ve açık bir kimlik veya başvuru dönüştürme sağlanan temel arabirimlerini `S` için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-179">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="07320-180">Herhangi *delegate_type* için `System.Delegate` ve arabirimlerini uygular.</span><span class="sxs-lookup"><span data-stu-id="07320-180">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="07320-181">Null değişmez değer herhangi bir gelen *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-181">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="07320-182">Herhangi *reference_type* için bir *reference_type* `T` örtük kimlik veya başvuru dönüştürmeleri varsa bir *reference_type* `T0` ve `T0` bir kimlik dönüştürmesi bulunmadığında `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-182">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="07320-183">Herhangi *reference_type* arabirim veya temsilci türünün `T` bir örtük kimlik veya başvuru dönüştürme bir arabirim veya temsilci türüne sahipse `T0` ve `T0` varyansı dönüştürülebilir (olduğu[ Varyans dönüştürme](interfaces.md#variance-conversion)) için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-183">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="07320-184">Başvuru türleri olarak bilinen tür parametreleri içeren örtük dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="07320-184">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="07320-185">Bkz: [tür parametreleri içeren örtük dönüştürmelerin](conversions.md#implicit-conversions-involving-type-parameters) tür parametreleri içeren örtük dönüştürmeleri hakkında daha fazla ayrıntı için.</span><span class="sxs-lookup"><span data-stu-id="07320-185">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="07320-186">Bu dönüştürmeler arasında örtük bir başvuru dönüşümleri olan *reference_type*her zaman başarılı olması için kanıtlanmış ve bu nedenle çalışma zamanında hiçbir denetim gerektiren s.</span><span class="sxs-lookup"><span data-stu-id="07320-186">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="07320-187">Başvuru dönüşümleri, örtük veya açık, hiçbir zaman dönüştürülen nesne başvuru kimliğini değiştirin.</span><span class="sxs-lookup"><span data-stu-id="07320-187">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="07320-188">Başvuru türü başvuru dönüştürmesi değişebilir olsa da başka bir deyişle, hiçbir zaman türü veya başvurulan nesnenin değerini değiştirir.</span><span class="sxs-lookup"><span data-stu-id="07320-188">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="07320-189">Kutulama dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-189">Boxing conversions</span></span>

<span data-ttu-id="07320-190">Kutulama dönüştürmesi izin veren bir *value_type* başvuru türüne örtük olarak dönüştürülecek.</span><span class="sxs-lookup"><span data-stu-id="07320-190">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="07320-191">Herhangi bir paketleme dönüştürmesi var *non_nullable_value_type* için `object` ve `dynamic`, `System.ValueType` ve herhangi bir *INTERFACE_TYPE* tarafından uygulanan *non_ nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-191">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="07320-192">Ayrıca bir *enum_type* türüne dönüştürülebilir `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="07320-192">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="07320-193">Gelen bir paketleme dönüştürmesi mevcut bir *nullable_type* temel bir başvuru türü için bulunuyorsa ve yalnızca bir paketleme dönüştürmesi var *non_nullable_value_type* başvuru türü.</span><span class="sxs-lookup"><span data-stu-id="07320-193">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="07320-194">Bir arabirim türüne paketleme dönüşümü bir değer türünde `I` Kutulama dönüştürmesi bir arabirim türüne sahipse `I0` ve `I0` bir kimlik dönüştürmesi bulunmadığında `I`.</span><span class="sxs-lookup"><span data-stu-id="07320-194">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="07320-195">Bir arabirim türüne paketleme dönüşümü bir değer türünde `I` bir arabirim veya temsilci türünün paketleme dönüştürmesi varsa `I0` ve `I0` varyansı dönüştürülebilir olduğundan ([varyansı dönüştürme](interfaces.md#variance-conversion)) için`I`.</span><span class="sxs-lookup"><span data-stu-id="07320-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="07320-196">Değerini kutulama bir *non_nullable_value_type* nesne örneğini tahsis etme ve kopyalama oluşur *value_type* değerini söz konusu örneğine dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="07320-196">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="07320-197">Bir yapı türü kutulanabilir `System.ValueType`, tümü yapı için temel sınıf olan bu yana ([devralma](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="07320-197">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="07320-198">Değerini kutulama bir *nullable_type* aşağıdaki gibi çalışır:</span><span class="sxs-lookup"><span data-stu-id="07320-198">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="07320-199">Kaynak değeri null ise (`HasValue` özellik değer: false), sonucu hedef türünün bir null başvurudur.</span><span class="sxs-lookup"><span data-stu-id="07320-199">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="07320-200">Aksi takdirde, sonucu bir paketlenmiş bir başvurudur `T` çözülme ve kaynak değeri kutulama tarafından üretilen.</span><span class="sxs-lookup"><span data-stu-id="07320-200">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="07320-201">Kutulama dönüştürmeleri daha ayrıntılı açıklanır [kutulama dönüştürmeler](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="07320-201">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="07320-202">Örtük dinamik dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-202">Implicit dynamic conversions</span></span>

<span data-ttu-id="07320-203">Türündeki bir ifade dinamik örtülü dönüştürme var `dynamic` herhangi bir tür için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-203">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="07320-204">Dönüştürme dinamik olarak bağlı ([dinamik bağlama](expressions.md#dynamic-binding)), yani örtük bir dönüştürme, çalışma zamanında çalışma zamanı tür ifade aranır `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-204">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="07320-205">Hiçbir dönüştürme bulunursa, bir çalışma zamanı özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="07320-205">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="07320-206">Bu örtük dönüştürme görünüşte başında öneriler ihlal Not [örtük dönüştürmelerin](conversions.md#implicit-conversions) örtük bir dönüştürme hiçbir zaman bir özel durum neden olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="07320-206">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="07320-207">Ancak bu dönüştürmeyi kendisi değil ancak *bulma* neden olan özel durumun dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="07320-207">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="07320-208">Çalışma zamanı özel durumlarını riskini dinamik bağlama kullanımını devralınır.</span><span class="sxs-lookup"><span data-stu-id="07320-208">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="07320-209">Dinamik bağlama dönüştürme istenildiği gibi değilse, ifade ilk dönüştürülebilir `object`ve ardından istenen türde.</span><span class="sxs-lookup"><span data-stu-id="07320-209">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="07320-210">Aşağıdaki örnek örtük dinamik dönüştürme gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="07320-210">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="07320-211">Atamaları `s2` ve `i` hem de bağlama işlemlerinin çalışma zamanı kadar askıya burada dinamik örtülü dönüştürmeler kullanmak istemiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="07320-211">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="07320-212">Çalışma zamanında, çalışma zamanı türünden örtük dönüştürmelerin aranır `d`  --  `string` --hedef türü.</span><span class="sxs-lookup"><span data-stu-id="07320-212">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="07320-213">Dönüştürme için bulunan `string` değil `int`.</span><span class="sxs-lookup"><span data-stu-id="07320-213">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="07320-214">Örtük sabit ifade dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-214">Implicit constant expression conversions</span></span>

<span data-ttu-id="07320-215">Örtük sabit ifade dönüştürme, aşağıdaki dönüştürmeleri izin verir:</span><span class="sxs-lookup"><span data-stu-id="07320-215">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="07320-216">A *constant_expression* ([sabit ifadeler](expressions.md#constant-expressions)) türü `int` türüne dönüştürülebilir `sbyte`, `byte`, `short`, `ushort`, `uint`, veya `ulong`, değerini sağlanan *constant_expression* hedef türünün aralığı içinde.</span><span class="sxs-lookup"><span data-stu-id="07320-216">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="07320-217">A *constant_expression* türü `long` türüne dönüştürülebilir `ulong`, değerini sağlanan *constant_expression* negatif değil.</span><span class="sxs-lookup"><span data-stu-id="07320-217">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="07320-218">Tür parametreleri içeren örtük dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-218">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="07320-219">Belirtilen tür parametresi için aşağıdaki örtük dönüştürmeler mevcut `T`:</span><span class="sxs-lookup"><span data-stu-id="07320-219">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="07320-220">Gelen `T` etkili temel sınıfı için `C`, gelen `T` tüm taban sınıfı için `C`, gelen ve giden `T` tarafından uygulanan herhangi bir arabirim için `C`.</span><span class="sxs-lookup"><span data-stu-id="07320-220">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="07320-221">AT çalışma zamanı Eğer `T` bir değer türü dönüştürme bir paketleme dönüştürmesi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-221">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="07320-222">Aksi takdirde, dönüştürme örtük bir başvuru dönüştürmesi veya kimlik dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-222">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="07320-223">Gelen `T` bir arabirim türüne `I` içinde `T`etkili arabirimi kümesinde ve `T` herhangi temel arabirimine `I`.</span><span class="sxs-lookup"><span data-stu-id="07320-223">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="07320-224">AT çalışma zamanı Eğer `T` bir değer türü dönüştürme bir paketleme dönüştürmesi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-224">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="07320-225">Aksi takdirde, dönüştürme örtük bir başvuru dönüştürmesi veya kimlik dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-225">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="07320-226">Gelen `T` bir tür parametresine `U`, sağlanan `T` bağlıdır `U` ([tür parametresi kısıtlamaları](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="07320-226">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="07320-227">AT çalışma zamanı Eğer `U` bir değer türü ise `T` ve `U` mutlaka aynı türdeyse ve hiçbir dönüştürme işlemi gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="07320-227">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="07320-228">Aksi takdirde `T` bir değer türü dönüştürme bir paketleme dönüştürmesi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-228">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="07320-229">Aksi takdirde, dönüştürme örtük bir başvuru dönüştürmesi veya kimlik dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-229">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="07320-230">Null değişmez değer gelen `T`, sağlanan `T` bir başvuru türü olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="07320-230">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="07320-231">Gelen `T` bir başvuru türü için `I` örtük bir dönüştürme için bir başvuru türü olup olmadığını `S0` ve `S0` bir kimlik dönüştürmesi bulunmadığında `S`.</span><span class="sxs-lookup"><span data-stu-id="07320-231">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="07320-232">Çalışma zamanında dönüştürme dönüştürme aynı şekilde yürütülür `S0`.</span><span class="sxs-lookup"><span data-stu-id="07320-232">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="07320-233">Gelen `T` bir arabirim türüne `I` bir arabirim veya temsilci türüne örtük bir dönüştürme varsa `I0` ve `I0` varyansı dönüştürülebilir olduğundan için `I` ([varyansı dönüştürme](interfaces.md#variance-conversion) ).</span><span class="sxs-lookup"><span data-stu-id="07320-233">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="07320-234">AT çalışma zamanı Eğer `T` bir değer türü dönüştürme bir paketleme dönüştürmesi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-234">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="07320-235">Aksi takdirde, dönüştürme örtük bir başvuru dönüştürmesi veya kimlik dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-235">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="07320-236">Varsa `T` bir başvuru türü olarak bilinen ([tür parametresi kısıtlamaları](classes.md#type-parameter-constraints)), yukarıdaki dönüştürmeleri tüm örtük bir başvuru dönüşümleri sınıflandırılan ([örtük bir başvuru dönüşümleri](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="07320-236">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="07320-237">Varsa `T` olan bir başvuru türü bilinmiyor, yukarıdaki dönüştürmeler kutulama dönüşümleri sınıflandırılan ([kutulama dönüştürmeler](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="07320-237">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="07320-238">Kullanıcı tanımlı örtük dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-238">User-defined implicit conversions</span></span>

<span data-ttu-id="07320-239">Başka bir isteğe bağlı standart örtük dönüştürme tarafından izlenen bir kullanıcı tanımlı örtük dönüştürme işleci yürütülmesini arkasından isteğe bağlı standart örtülü dönüştürme, kullanıcı tanımlı bir örtük dönüştürme oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-239">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="07320-240">Kullanıcı tanımlı örtük dönüştürmelerin değerlendirmek için kesin kurallar açıklanan [kullanıcı tanımlı örtük dönüştürmeler işleme](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="07320-240">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="07320-241">Anonim işlev dönüştürmeler veya yöntem grubu dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-241">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="07320-242">Anonim işlevler ve yöntem grupları türleri içinde ve kendilerini yoktur, ancak türleri ya da ifade ağaç türleri temsilci seçmek için örtük olarak dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="07320-242">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="07320-243">Anonim işlev dönüştürmeleri daha ayrıntılı olarak açıklanmıştır [anonim işlev dönüştürmeler](conversions.md#anonymous-function-conversions) ve yöntem grubu Dönüşümlerde [yöntem grubu dönüştürmeler](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="07320-243">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="07320-244">Açık dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-244">Explicit conversions</span></span>

<span data-ttu-id="07320-245">Aşağıdaki dönüştürmeleri, açık dönüştürmeler sınıflandırılan:</span><span class="sxs-lookup"><span data-stu-id="07320-245">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="07320-246">Tüm örtük dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="07320-246">All implicit conversions.</span></span>
*  <span data-ttu-id="07320-247">Açık sayısal dönüşümler.</span><span class="sxs-lookup"><span data-stu-id="07320-247">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="07320-248">Açık numaralandırma dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="07320-248">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="07320-249">Açık dönüştürmeler boş değer atanabilir.</span><span class="sxs-lookup"><span data-stu-id="07320-249">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="07320-250">Açık bir başvuru dönüşümleri.</span><span class="sxs-lookup"><span data-stu-id="07320-250">Explicit reference conversions.</span></span>
*  <span data-ttu-id="07320-251">Açık arabirim dönüşümler.</span><span class="sxs-lookup"><span data-stu-id="07320-251">Explicit interface conversions.</span></span>
*  <span data-ttu-id="07320-252">Kutudan çıkarma dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="07320-252">Unboxing conversions.</span></span>
*  <span data-ttu-id="07320-253">Dinamik açık dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-253">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="07320-254">Kullanıcı tanımlı açık dönüştürmeler.</span><span class="sxs-lookup"><span data-stu-id="07320-254">User-defined explicit conversions.</span></span>

<span data-ttu-id="07320-255">Açık dönüştürmeler cast ifadeleri meydana gelebilir ([Cast ifadeleri](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="07320-255">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="07320-256">Açık dönüştürmeler tüm örtük dönüştürmelerin içermektedir.</span><span class="sxs-lookup"><span data-stu-id="07320-256">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="07320-257">Başka bir deyişle, yedekli cast ifadeleri izin verilir.</span><span class="sxs-lookup"><span data-stu-id="07320-257">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="07320-258">Örtük dönüştürmeleri olmayan açık dönüştürmeler türleri merit açık yeterince farklı etki alanlarında her zaman başarılı olması için kanıtlanmış olamaz dönüştürmeler, büyük olasılıkla bilgileri kaybedersiniz bilinen dönüştürmeler ve dönüştürmeler olan gösterim.</span><span class="sxs-lookup"><span data-stu-id="07320-258">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="07320-259">Açık sayısal dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-259">Explicit numeric conversions</span></span>

<span data-ttu-id="07320-260">Açık sayısal dönüşümler dönüşümlerse olan bir *numeric_type* diğerine *numeric_type* kendisi için bir örtülü sayısal dönüştürme ([örtük sayısal dönüşümler](conversions.md#implicit-numeric-conversions)) zaten mevcut değil:</span><span class="sxs-lookup"><span data-stu-id="07320-260">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="07320-261">Gelen `sbyte` için `byte`, `ushort`, `uint`, `ulong`, veya `char`.</span><span class="sxs-lookup"><span data-stu-id="07320-261">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="07320-262">Gelen `byte` için `sbyte` ve `char`.</span><span class="sxs-lookup"><span data-stu-id="07320-262">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="07320-263">Gelen `short` için `sbyte`, `byte`, `ushort`, `uint`, `ulong`, veya `char`.</span><span class="sxs-lookup"><span data-stu-id="07320-263">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="07320-264">Gelen `ushort` için `sbyte`, `byte`, `short`, veya `char`.</span><span class="sxs-lookup"><span data-stu-id="07320-264">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="07320-265">Gelen `int` için `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, veya `char`.</span><span class="sxs-lookup"><span data-stu-id="07320-265">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="07320-266">Gelen `uint` için `sbyte`, `byte`, `short`, `ushort`, `int`, veya `char`.</span><span class="sxs-lookup"><span data-stu-id="07320-266">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="07320-267">Gelen `long` için `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, veya `char`.</span><span class="sxs-lookup"><span data-stu-id="07320-267">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="07320-268">Gelen `ulong` için `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, veya `char`.</span><span class="sxs-lookup"><span data-stu-id="07320-268">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="07320-269">Gelen `char` için `sbyte`, `byte`, veya `short`.</span><span class="sxs-lookup"><span data-stu-id="07320-269">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="07320-270">Gelen `float` için `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-270">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-271">Gelen `double` için `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-271">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-272">Gelen `decimal` için `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, veya `double`.</span><span class="sxs-lookup"><span data-stu-id="07320-272">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="07320-273">Açık dönüştürmeler tüm örtük ve açık sayısal dönüşümler içerdiğinden, her zaman herhangi bir dönüştürme mümkün *numeric_type* herhangi diğer *numeric_type* atama ifadesi (kullanma [Cast ifadeleri](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="07320-273">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="07320-274">Açık sayısal dönüştürmeler, büyük olasılıkla bilgileri kaybeder veya büyük olasılıkla özel durum oluşturulmasına neden.</span><span class="sxs-lookup"><span data-stu-id="07320-274">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="07320-275">Açık sayısal dönüştürme şu şekilde işlenir:</span><span class="sxs-lookup"><span data-stu-id="07320-275">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="07320-276">İçin bir integral türünden başka bir integral türüne dönüştürme, içerik denetleme overflow'da işleme bağlıdır ([checked ve unchecked işleçleri](expressions.md#the-checked-and-unchecked-operators)) dönüştürme aldığı yerleştirin:</span><span class="sxs-lookup"><span data-stu-id="07320-276">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="07320-277">İçinde bir `checked` bağlamı, dönüştürmenin başarılı kaynak işlecinin değeri hedef türün aralığı içinde ancak oluşturur bir `System.OverflowException` kaynak işlecinin değeri hedef türün aralığı dışında ise.</span><span class="sxs-lookup"><span data-stu-id="07320-277">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="07320-278">İçinde bir `unchecked` bağlamını, dönüştürme her zaman başarılı olur ve aşağıdaki gibi çalışır.</span><span class="sxs-lookup"><span data-stu-id="07320-278">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="07320-279">Kaynak türü hedef türünden daha büyük ise sonra kaynak değeri, "fazladan" atarak kesilmiş en önemli bitleri.</span><span class="sxs-lookup"><span data-stu-id="07320-279">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="07320-280">Sonuç, ardından hedef türünde bir değer kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="07320-280">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="07320-281">Kaynak türü, hedef türünden küçükse, hedef türüyle aynı boyutta olması ardından kaynağı işaret genişletilmiş veya sıfır genişletilmiş değeridir.</span><span class="sxs-lookup"><span data-stu-id="07320-281">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="07320-282">Kaynak türü açtıysanız oturum uzantısı kullanılır. Kaynak türü imzalanmamış ise sıfır uzantısı kullanılır.</span><span class="sxs-lookup"><span data-stu-id="07320-282">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="07320-283">Sonuç, ardından hedef türünde bir değer kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="07320-283">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="07320-284">Hedef türü olarak aynı boyutta kaynak türü ise kaynak değer hedef türünde bir değer kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="07320-284">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="07320-285">Dönüştürme için `decimal` integral türü için kaynak değeri sıfır en yakın tamsayı değerine yuvarlanır ve dönüştürme sonucu olarak bu tamsayı değeri olur.</span><span class="sxs-lookup"><span data-stu-id="07320-285">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="07320-286">Sonuçta elde edilen tamsayı değeri hedef türün aralığı dışında ise bir `System.OverflowException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="07320-286">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="07320-287">Dönüştürme için `float` veya `double` integral türü için içerik denetimi overflow'da işleme bağlıdır ([checked ve unchecked işleçleri](expressions.md#the-checked-and-unchecked-operators)) dönüştürme aldığı yerleştirin:</span><span class="sxs-lookup"><span data-stu-id="07320-287">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="07320-288">İçinde bir `checked` bağlamı, dönüştürme geçer gibi:</span><span class="sxs-lookup"><span data-stu-id="07320-288">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="07320-289">İşlenenin NaN veya sonsuz, olması durumunda bir `System.OverflowException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="07320-289">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="07320-290">Aksi takdirde, kaynak işlenen sıfır en yakın tamsayı değerine yuvarlanır.</span><span class="sxs-lookup"><span data-stu-id="07320-290">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="07320-291">Bu tamsayı değeri hedef türün aralığı içinde ise, ardından bu dönüştürme sonucu olarak değerdir.</span><span class="sxs-lookup"><span data-stu-id="07320-291">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="07320-292">Aksi takdirde, bir `System.OverflowException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="07320-292">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="07320-293">İçinde bir `unchecked` bağlamını, dönüştürme her zaman başarılı olur ve aşağıdaki gibi çalışır.</span><span class="sxs-lookup"><span data-stu-id="07320-293">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="07320-294">İşlenenin NaN veya sonsuz ise, dönüştürmenin sonucu hedef türü belirtilmemiş bir değerdir.</span><span class="sxs-lookup"><span data-stu-id="07320-294">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="07320-295">Aksi takdirde, kaynak işlenen sıfır en yakın tamsayı değerine yuvarlanır.</span><span class="sxs-lookup"><span data-stu-id="07320-295">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="07320-296">Bu tamsayı değeri hedef türün aralığı içinde ise, ardından bu dönüştürme sonucu olarak değerdir.</span><span class="sxs-lookup"><span data-stu-id="07320-296">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="07320-297">Aksi takdirde, dönüştürmenin sonucu hedef türü belirtilmemiş bir değerdir.</span><span class="sxs-lookup"><span data-stu-id="07320-297">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="07320-298">Dönüştürme için `double` için `float`, `double` değer yuvarlanır en yakın `float` değeri.</span><span class="sxs-lookup"><span data-stu-id="07320-298">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="07320-299">Varsa `double` değeri olarak temsil etmek için çok küçük bir `float`, sonuç pozitif sıfır veya negatif sıfır.</span><span class="sxs-lookup"><span data-stu-id="07320-299">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="07320-300">Varsa `double` değeri olarak temsil etmek için çok büyük bir `float`, sonuç Pozitif sonsuz veya negatif sonsuz olur.</span><span class="sxs-lookup"><span data-stu-id="07320-300">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="07320-301">Varsa `double` değeri NaN ise, NaN sonucudur de.</span><span class="sxs-lookup"><span data-stu-id="07320-301">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="07320-302">Dönüştürme için `float` veya `double` için `decimal`, kaynak değeri dönüştürülür `decimal` gösterimi ve gerekirse 28 ondalık basamağın sonra en yakın sayıya yuvarlanmasını ([decimal türü](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="07320-302">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="07320-303">Kaynak değeri olarak temsil etmek için çok küçük ise bir `decimal`, sıfır sonuç olur.</span><span class="sxs-lookup"><span data-stu-id="07320-303">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="07320-304">Kaynak değeri NaN ise, sonsuz veya olarak göstermek için çok büyük bir `decimal`, `System.OverflowException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="07320-304">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="07320-305">Dönüştürme için `decimal` için `float` veya `double`, `decimal` değer yuvarlanır en yakın `double` veya `float` değeri.</span><span class="sxs-lookup"><span data-stu-id="07320-305">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="07320-306">Bu dönüştürme duyarlık kaybedebileceği olsa da, hiçbir zaman bir özel durum oluşturulmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="07320-306">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="07320-307">Açık numaralandırma dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-307">Explicit enumeration conversions</span></span>

<span data-ttu-id="07320-308">Açık numaralandırma dönüştürmeler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="07320-308">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="07320-309">Gelen `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, veya `decimal` herhangi için*enum_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-309">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="07320-310">Herhangi *enum_type* için `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, veya `decimal`.</span><span class="sxs-lookup"><span data-stu-id="07320-310">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="07320-311">Herhangi *enum_type* herhangi diğer *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-311">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="07320-312">İki tür arasında bir açık numaralandırma dönüştürme katılan tüm düşünerek işlenen *enum_type* , temel alınan türü olarak *enum_type*ve ardından kapalı veya açık gerçekleştirme Sonuç türleri arasında sayısal dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="07320-312">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="07320-313">Örneğin, belirtilen bir *enum_type* `E` ile ve temel alınan türü `int`, dönüştürme `E` için `byte` açık bir sayısal dönüştürme olarak işlenir ([açık sayısal dönüşümler](conversions.md#explicit-numeric-conversions)) öğesinden `int` için `byte`ve dönüştürme `byte` için `E` örtük sayısal dönüştürme olarak işlenir ([örtük sayısal dönüşümler](conversions.md#implicit-numeric-conversions)) gelen `byte` için `int`.</span><span class="sxs-lookup"><span data-stu-id="07320-313">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="07320-314">Boş değer atanabilir açık dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-314">Explicit nullable conversions</span></span>

<span data-ttu-id="07320-315">***Boş değer atanabilir açık dönüştürmeler*** izin da bu türlerin boş değer atanabilir forms ile kullanılmak üzere atanamayan değer türleri üzerinde çalışan açık dönüştürmeler önceden tanımlanmış.</span><span class="sxs-lookup"><span data-stu-id="07320-315">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="07320-316">Her bir NULL olmayan değer türünden dönüştürme önceden tanımlanmış açık dönüştürmeler `S` NULL olmayan bir değer türü için `T` ([kimlik dönüştürme](conversions.md#identity-conversion), [örtük sayısal dönüşümler](conversions.md#implicit-numeric-conversions), [Numaralandırma örtük dönüştürmeleri](conversions.md#implicit-enumeration-conversions), [açık sayısal dönüşümler](conversions.md#explicit-numeric-conversions), ve [açık numaralandırma dönüştürmeler](conversions.md#explicit-enumeration-conversions)), aşağıdaki boş değer atanabilir dönüştürmeler mevcuttur:</span><span class="sxs-lookup"><span data-stu-id="07320-316">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="07320-317">Açık bir dönüştürme `S?` için `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-317">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="07320-318">Açık bir dönüştürme `S` için `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-318">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="07320-319">Açık bir dönüştürme `S?` için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-319">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="07320-320">Boş değer atanabilir bir dönüştürmenin değerlendirme, temel alınan bir dönüştürme temel `S` için `T` aşağıdaki gibi çalışır:</span><span class="sxs-lookup"><span data-stu-id="07320-320">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="07320-321">Boş değer atanabilir bir dönüştürme ise `S?` için `T?`:</span><span class="sxs-lookup"><span data-stu-id="07320-321">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="07320-322">Kaynak değeri null ise (`HasValue` özellik değer: false), sonuç türü null değeri `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-322">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="07320-323">Aksi takdirde, dönüştürme bir gelen çözülme olarak değerlendirilir `S?` için `S`, temel alınan dönüştürme işlemi tarafından izlenen `S` için `T`diğerine kaydırma çizgidir `T` için `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-323">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="07320-324">Boş değer atanabilir bir dönüştürme ise `S` için `T?`, dönüştürme temel alınan dönüştürme işlemini değerlendirmesinde `S` için `T` diğerine kaydırma ardından `T` için `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-324">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="07320-325">Boş değer atanabilir bir dönüştürme ise `S?` için `T`, dönüştürme, bir gelen çözülme olarak değerlendirilir `S?` için `S` temel dönüştürme ardından `S` için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-325">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="07320-326">Değer ise bir boş değer atanabilir değer sarmalamadan çıkarma girişimi, bir özel durum oluşturur Not `null`.</span><span class="sxs-lookup"><span data-stu-id="07320-326">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="07320-327">Açık bir başvuru dönüşümleri</span><span class="sxs-lookup"><span data-stu-id="07320-327">Explicit reference conversions</span></span>

<span data-ttu-id="07320-328">Açık bir başvuru dönüşümleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="07320-328">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="07320-329">Gelen `object` ve `dynamic` herhangi diğer *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-329">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="07320-330">Herhangi *class_type* `S` herhangi *class_type* `T`, sağlanan `S` bir taban sınıfıdır `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-330">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="07320-331">Herhangi *class_type* `S` herhangi *INTERFACE_TYPE* `T`, sağlanan `S` korumalı sağlanan değilse ve `S` uygulamıyor `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-331">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="07320-332">Herhangi *INTERFACE_TYPE* `S` herhangi *class_type* `T`, sağlanan `T` korumalı sağlanan ya da `T` uygulayan `S`.</span><span class="sxs-lookup"><span data-stu-id="07320-332">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="07320-333">Herhangi *INTERFACE_TYPE* `S` herhangi *INTERFACE_TYPE* `T`, sağlanan `S` türünden türetilmediğinden `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-333">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="07320-334">Gelen bir *array_type* `S` bir öğe türü ile `SE` için bir *array_type* `T` bir öğe türü ile `TE`, aşağıdakilerin tümü doğru şunlardır:</span><span class="sxs-lookup"><span data-stu-id="07320-334">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="07320-335">`S` ve `T` yalnızca öğe türleri farklı.</span><span class="sxs-lookup"><span data-stu-id="07320-335">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="07320-336">Diğer bir deyişle, `S` ve `T` aynı sayıda boyuta sahip.</span><span class="sxs-lookup"><span data-stu-id="07320-336">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="07320-337">Her ikisi de `SE` ve `TE` olan *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="07320-337">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="07320-338">Gelen bir açık bir başvuru dönüştürmesi var `SE` için `TE`.</span><span class="sxs-lookup"><span data-stu-id="07320-338">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="07320-339">Gelen `System.Array` ve arabirimler için uygular *array_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-339">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="07320-340">Bir tek boyutlu dizi türünden `S[]` için `System.Collections.Generic.IList<T>` ve bir açık başvuru dönüştürme sağlanan temel arabirimlerini `S` için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-340">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="07320-341">Gelen `System.Collections.Generic.IList<S>` ve bunun temel arabirimleri için bir tek boyutlu dizi türü `T[]`, bir açık kimlik veya başvuru dönüştürme olmasını sağlanan `S` için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-341">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="07320-342">Gelen `System.Delegate` ve arabirimler için uygular *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-342">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="07320-343">Bir başvuru türü için bir başvuru türünden `T` bir açık bir başvuru dönüştürmesi için bir başvuru türü olup olmadığını `T0` ve `T0` sahip bir kimlik dönüştürme `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-343">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="07320-344">Bir arabirim veya temsilci türüne başvuru türünden `T` arabirim veya temsilci türünün bir açık bir başvuru dönüştürmesi varsa `T0` ve her iki `T0` varyansı dönüştürülebilir olduğundan için `T` veya `T` olduğu Varyans dönüştürülebilir `T0` ([varyansı dönüştürme](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="07320-344">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="07320-345">Gelen `D<S1...Sn>` için `D<T1...Tn>` burada `D<X1...Xn>` bir genel temsilci türünde `D<S1...Sn>` uyumlu ya da aynı `D<T1...Tn>`ve her tür parametresi için `Xi` , `D` aşağıdaki tutar:</span><span class="sxs-lookup"><span data-stu-id="07320-345">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="07320-346">Varsa `Xi` sabit, ise `Si` aynıdır `Ti`.</span><span class="sxs-lookup"><span data-stu-id="07320-346">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="07320-347">Varsa `Xi` değişkendir, sonra bir örtük veya açık kimlik veya başvuru dönüştürmesi `Si` için `Ti`.</span><span class="sxs-lookup"><span data-stu-id="07320-347">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="07320-348">Varsa `Xi` değişken karşıtı, ise `Si` ve `Ti` ötekisi özdeş veya her ikisi de başvuru türleri.</span><span class="sxs-lookup"><span data-stu-id="07320-348">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="07320-349">Başvuru türleri olarak bilinen tür parametreleri içeren açık dönüştürmeler.</span><span class="sxs-lookup"><span data-stu-id="07320-349">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="07320-350">Tür parametreleri içeren açık dönüştürmeler hakkında daha fazla bilgi için bkz. [tür parametreleri içeren açık dönüştürmeler](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="07320-350">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="07320-351">Bu dönüştürmeler doğru olduklarından emin olmak için çalışma zamanı denetimleri gerektiren başvuru türleri arasında açık bir başvuru dönüşümleri var.</span><span class="sxs-lookup"><span data-stu-id="07320-351">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="07320-352">Açık bir başvuru dönüştürmesi çalışma zamanında başarılı olması bir kaynak işlecinin değer olmalıdır `null`, ya da gerçek kaynak işlenen tarafından başvurulan nesne türü hedef türe örtük bir başvuru tarafından dönüştürülebilir bir türü olmalıdır dönüştürme ([örtük bir başvuru dönüşümleri](conversions.md#implicit-reference-conversions)) veya paketleme dönüştürmesi ([kutulama dönüştürmeler](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="07320-352">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="07320-353">Bir açık başvuru dönüştürme başarısız olursa bir `System.InvalidCastException` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="07320-353">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="07320-354">Başvuru dönüşümleri, örtük veya açık, hiçbir zaman dönüştürülen nesne başvuru kimliğini değiştirin.</span><span class="sxs-lookup"><span data-stu-id="07320-354">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="07320-355">Başvuru türü başvuru dönüştürmesi değişebilir olsa da başka bir deyişle, hiçbir zaman türü veya başvurulan nesnenin değerini değiştirir.</span><span class="sxs-lookup"><span data-stu-id="07320-355">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="07320-356">Kutudan çıkarma dönüştürme</span><span class="sxs-lookup"><span data-stu-id="07320-356">Unboxing conversions</span></span>

<span data-ttu-id="07320-357">Bir başvuru türünün açıkça dönüştürülmesi için bir paket açma dönüşümünün izin veren bir *value_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-357">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="07320-358">Bir paketi açma dönüştürmesi var türlerinden `object`, `dynamic` ve `System.ValueType` herhangi *non_nullable_value_type*ve herhangi *INTERFACE_TYPE* herhangi *non_ nullable_value_type* uygulayan *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="07320-358">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="07320-359">Ayrıca yazın `System.Enum` herhangi kutulanmamış olabilir *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-359">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="07320-360">Bir başvuru türü için gelen bir paketi açma dönüştürmesi mevcut bir *nullable_type* temel alınan bir paket açma dönüşümünün başvuru türü varsa *non_nullable_value_type* ,  *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-360">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="07320-361">Bir değer türü `S` sahip bir paketi açma dönüştürmesi bir arabirim türünden `I` dönüşümünün bir arabirim türünden olup olmadığını `I0` ve `I0` bir kimlik dönüştürmesi bulunmadığında `I`.</span><span class="sxs-lookup"><span data-stu-id="07320-361">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="07320-362">Bir değer türü `S` sahip bir paketi açma dönüştürmesi bir arabirim türünden `I` bir arabirim veya temsilci türünden bir paketi açma dönüştürmesi varsa `I0` ve her iki `I0` varyansı dönüştürülebilir olduğundan için `I` veya `I`varyansı dönüştürülebilir olduğundan için `I0` ([varyansı dönüştürme](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="07320-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="07320-363">Bir kutudan çıkarma işlemi, ilk nesne örneği, kutulanmış bir değer olan denetimini oluşur verilen *value_type*ve ardından değeri örneğinin dışında kopyalama.</span><span class="sxs-lookup"><span data-stu-id="07320-363">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="07320-364">Bir null başvuru kutudan çıkarma bir *nullable_type* null değerini üretir *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="07320-364">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="07320-365">Bir yapı türünden kutulanmamış `System.ValueType`, tümü yapı için temel sınıf olan bu yana ([devralma](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="07320-365">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="07320-366">Kutudan çıkarma dönüştürme daha ayrıntılı açıklanır [kutudan çıkarma dönüştürme](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="07320-366">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="07320-367">Dinamik açık dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-367">Explicit dynamic conversions</span></span>

<span data-ttu-id="07320-368">Türündeki bir ifade açık dinamik dönüştürme var `dynamic` herhangi bir tür için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-368">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="07320-369">Dönüştürme dinamik olarak bağlı ([dinamik bağlama](expressions.md#dynamic-binding)), yani açık bir dönüştürme, çalışma zamanında çalışma zamanı tür ifade aranır `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-369">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="07320-370">Hiçbir dönüştürme bulunursa, bir çalışma zamanı özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="07320-370">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="07320-371">Dinamik bağlama dönüştürme istenildiği gibi değilse, ifade ilk dönüştürülebilir `object`ve ardından istenen türde.</span><span class="sxs-lookup"><span data-stu-id="07320-371">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="07320-372">Aşağıdaki sınıf tanımlanan varsayın:</span><span class="sxs-lookup"><span data-stu-id="07320-372">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="07320-373">Aşağıdaki örnekte, dinamik açık dönüştürmeler gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="07320-373">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="07320-374">En iyi dönüştürülmesi `o` için `C` derleme olması bir açık bir başvuru dönüştürmesi sırasında bulunamadı.</span><span class="sxs-lookup"><span data-stu-id="07320-374">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="07320-375">Bu çalışma zamanında, çünkü başarısız `"1"` aslında değil bir `C`.</span><span class="sxs-lookup"><span data-stu-id="07320-375">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="07320-376">Dönüştürme `d` için `C` ancak, çalışma zamanı, çalışma zamanı tür dönüştürme tanımlandığı bir kullanıcı için açık dinamik bir dönüştürme askıya `d`  --  `string` --çok `C` bulunursa ve başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="07320-376">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="07320-377">Tür parametreleri içeren açık dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-377">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="07320-378">Belirtilen tür parametresi için aşağıdaki açık dönüştürmeler mevcut `T`:</span><span class="sxs-lookup"><span data-stu-id="07320-378">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="07320-379">Etkili temel sınıftan `C` , `T` için `T` ve herhangi bir taban sınıftan `C` için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-379">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="07320-380">AT çalışma zamanı Eğer `T` bir değer türü dönüştürme bir kutudan çıkarma dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-380">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="07320-381">Aksi takdirde, dönüştürme açık bir başvuru dönüştürmesi veya kimlik dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-381">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="07320-382">İçin herhangi bir arabirim türünden `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-382">From any interface type to `T`.</span></span> <span data-ttu-id="07320-383">AT çalışma zamanı Eğer `T` bir değer türü dönüştürme bir kutudan çıkarma dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-383">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="07320-384">Aksi takdirde, dönüştürme açık bir başvuru dönüştürmesi veya kimlik dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-384">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="07320-385">Gelen `T` herhangi *INTERFACE_TYPE* `I` örtük bir dönüştürme yok sağlanan `T` için `I`.</span><span class="sxs-lookup"><span data-stu-id="07320-385">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="07320-386">AT çalışma zamanı Eğer `T` bir değer türü dönüştürme bir açık bir başvuru dönüştürmesi tarafından izlenen bir paketleme dönüştürmesi olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-386">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="07320-387">Aksi takdirde, dönüştürme açık bir başvuru dönüştürmesi veya kimlik dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-387">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="07320-388">Bir tür parametresi'den `U` için `T`, sağlanan `T` bağlıdır `U` ([tür parametresi kısıtlamaları](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="07320-388">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="07320-389">AT çalışma zamanı Eğer `U` bir değer türü ise `T` ve `U` mutlaka aynı türdeyse ve hiçbir dönüştürme işlemi gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="07320-389">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="07320-390">Aksi takdirde `T` bir değer türü dönüştürme bir kutudan çıkarma dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-390">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="07320-391">Aksi takdirde, dönüştürme açık bir başvuru dönüştürmesi veya kimlik dönüştürme olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-391">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="07320-392">Varsa `T` olan bir başvuru türü olarak bilinen, yukarıdaki dönüştürmeleri tüm açık başvuru dönüşümleri sınıflandırılan ([açık başvuru dönüşümleri](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="07320-392">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="07320-393">Varsa `T` olan bir başvuru türü bilinmiyor, yukarıdaki dönüştürmeler kutudan çıkarma dönüştürme sınıflandırılan ([kutudan çıkarma dönüştürme](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="07320-393">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="07320-394">Yukarıdaki kuralları, şaşırtıcı olabilir bir sınırlandırılmamış tür parametresi doğrudan Açık dönüştürme bir arabirim olmayan türe izin vermez.</span><span class="sxs-lookup"><span data-stu-id="07320-394">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="07320-395">Bu kural için bir neden, Karışıklığı önlemek ve semantikleri açık tür dönüştürmeleri yapmaktır.</span><span class="sxs-lookup"><span data-stu-id="07320-395">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="07320-396">Örneğin, aşağıdaki bildirimi ele alalım:</span><span class="sxs-lookup"><span data-stu-id="07320-396">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="07320-397">Varsa doğrudan açıkça dönüştürülmesini `t` için `int` bir kolayca beklenebilir izni, `X<int>.F(7)` döndürecekti `7L`.</span><span class="sxs-lookup"><span data-stu-id="07320-397">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="07320-398">Standart sayısal dönüştürmeler, yalnızca türleri bağlama zamanında sayısal bir değer olduğunda kabul edildiği için ancak bunu istemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="07320-398">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="07320-399">Semantiği yapmak için Temizle, yukarıdaki örnekte bunun yerine yazılmış olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="07320-399">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="07320-400">Bu kod artık derlemez ancak yürütme `X<int>.F(7)` ardından çalışma zamanında, bu yana paketlenmiş bir özel durum `int` doğrudan dönüştürülemeyen bir `long`.</span><span class="sxs-lookup"><span data-stu-id="07320-400">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="07320-401">Kullanıcı tanımlı açık dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-401">User-defined explicit conversions</span></span>

<span data-ttu-id="07320-402">Başka bir isteğe bağlı standart açık dönüştürme tarafından izlenen bir kullanıcı tanımlı dönüştürme örtük veya açık işlecinin yürütme sonrasında isteğe bağlı standart açık dönüştürme, kullanıcı tanımlı açık dönüştürme oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-402">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="07320-403">Kullanıcı tanımlı açık dönüştürmeler değerlendirmek için kesin kurallar açıklanan [kullanıcı tanımlı açık dönüştürmeler işleme](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="07320-403">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="07320-404">Standart dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-404">Standard conversions</span></span>

<span data-ttu-id="07320-405">Standart dönüştürmeler bir kullanıcı tanımlı dönüştürme bir parçası olarak ortaya çıkabilecek bu önceden tanımlı dönüşümler ' dir.</span><span class="sxs-lookup"><span data-stu-id="07320-405">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="07320-406">Standart örtük dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-406">Standard implicit conversions</span></span>

<span data-ttu-id="07320-407">Aşağıdaki örtük dönüştürmeler standart örtük dönüştürmeler sınıflandırılan:</span><span class="sxs-lookup"><span data-stu-id="07320-407">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="07320-408">Kimlik dönüştürme ([kimlik dönüştürme](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="07320-408">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="07320-409">Örtük sayısal Dönüşümler ([örtük sayısal dönüşümler](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="07320-409">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="07320-410">Boş değer atanabilir örtülü dönüştürmeler ([boş değer atanabilir örtük dönüştürmelerin](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="07320-410">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="07320-411">Örtük bir başvuru Dönüşümleri ([örtük bir başvuru dönüşümleri](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="07320-411">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="07320-412">Kutulama dönüştürmeler ([kutulama dönüştürmeler](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="07320-412">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="07320-413">Örtük sabit ifade dönüştürmeler ([dinamik örtük dönüştürmelerin](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="07320-413">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="07320-414">Tür parametreleri içeren örtülü dönüştürmeler ([tür parametreleri içeren örtük dönüştürmelerin](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="07320-414">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="07320-415">Standart örtük dönüştürmeler, örtük dönüştürmelerin kullanıcı tanımlı özellikle hariç tutun.</span><span class="sxs-lookup"><span data-stu-id="07320-415">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="07320-416">Standart açık dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-416">Standard explicit conversions</span></span>

<span data-ttu-id="07320-417">Standart açık dönüştürmeler, tüm standart örtük dönüştürmeler yanı sıra alt kümesini bir ters standart örtük dönüştürme bulunduğu açık dönüştürmeler ' dir.</span><span class="sxs-lookup"><span data-stu-id="07320-417">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="07320-418">Diğer bir deyişle, standart bir örtük dönüştürme bir türden varsa `A` türüne `B`, standart bir açık dönüştürme türünden varsa `A` türüne `B` ve türünden `B` türüne `A`.</span><span class="sxs-lookup"><span data-stu-id="07320-418">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="07320-419">Kullanıcı tanımlı dönüşümler</span><span class="sxs-lookup"><span data-stu-id="07320-419">User-defined conversions</span></span>

<span data-ttu-id="07320-420">C# ile genişletilmesi önceden tanımlanmış örtük ve açık dönüştürmeler sağlar ***kullanıcı tanımlı dönüşümler***.</span><span class="sxs-lookup"><span data-stu-id="07320-420">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="07320-421">Dönüştürme işleçleri bildirerek kullanıcı tanımlı dönüştürmeler sunulmuştur ([dönüştürme işleçleri](classes.md#conversion-operators)) sınıf ile yapı türleri.</span><span class="sxs-lookup"><span data-stu-id="07320-421">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="07320-422">Kullanıcı tanımlı Dönüştürmelere izin verilir</span><span class="sxs-lookup"><span data-stu-id="07320-422">Permitted user-defined conversions</span></span>

<span data-ttu-id="07320-423">C# bildirilmesi için yalnızca belirli kullanıcı tanımlı Dönüştürmelere izin verir.</span><span class="sxs-lookup"><span data-stu-id="07320-423">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="07320-424">Özellikle, zaten var olan bir örtük veya açık dönüştürme tanımlanacak mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="07320-424">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="07320-425">Belirtilen kaynak türü için `S` ve hedef türü `T`, `S` veya `T` boş değer atanabilir türler izin `S0` ve `T0` Aksi takdirde, temel alınan türler için başvuru `S0` ve `T0` olan eşit `S` ve `T` sırasıyla.</span><span class="sxs-lookup"><span data-stu-id="07320-425">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="07320-426">Bir kaynak türünden dönüştürme bildirmek için bir sınıf veya yapı izin `S` hedef türüyle `T` yalnızca aşağıdakilerin tümü doğru olduğunda:</span><span class="sxs-lookup"><span data-stu-id="07320-426">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="07320-427">`S0` ve `T0` farklı tür aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="07320-427">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="07320-428">Ya da `S0` veya `T0` işleç bildirimi yer alan sınıf veya yapı türü.</span><span class="sxs-lookup"><span data-stu-id="07320-428">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="07320-429">Ne `S0` ya da `T0` olduğu bir *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="07320-429">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="07320-430">Kullanıcı tanımlı dönüşümler, bir dönüştürme yok gelen `S` için `T` veya `T` için `S`.</span><span class="sxs-lookup"><span data-stu-id="07320-430">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="07320-431">Kullanıcı tanımlı dönüştürmeler için kısıtlamalar açıklanan daha ayrıntılı olarak [dönüştürme işleçleri](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="07320-431">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="07320-432">Yükseltilmiş dönüştürme işleçleri</span><span class="sxs-lookup"><span data-stu-id="07320-432">Lifted conversion operators</span></span>

<span data-ttu-id="07320-433">Bir NULL olmayan değer türünden dönüştüren bir kullanıcı tanımlı dönüştürme işleci göz önünde bulundurulduğunda `S` NULL olmayan bir değer türü için `T`, ***dönüştürme işleci yükseltilmiş*** var. Bu dönüştürür gelen `S?` için`T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-433">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="07320-434">Bu yükseltilmiş dönüştürme işleci bir gelen çözülmesini gerçekleştirir `S?` için `S` kullanıcı tanımlı dönüştürme ardından `S` için `T` diğerine kaydırma ardından `T` için `T?`dışında bir null değerli `S?` doğrudan bir null değerli dönüştürür `T?`.</span><span class="sxs-lookup"><span data-stu-id="07320-434">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="07320-435">Yükseltilmiş dönüştürme işleci, temel alınan kullanıcı tanımlı dönüştürme işleci olarak aynı örtük veya açık sınıflandırma vardır.</span><span class="sxs-lookup"><span data-stu-id="07320-435">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="07320-436">"Kullanıcı tanımlı dönüştürme" her ikisi de kullanımını geçerli dönem, kullanıcı tanımlı ve dönüştürme işleçleri yükseltilmiş.</span><span class="sxs-lookup"><span data-stu-id="07320-436">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="07320-437">Kullanıcı tanımlı dönüşümler değerlendirmesi</span><span class="sxs-lookup"><span data-stu-id="07320-437">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="07320-438">Bir kullanıcı tanımlı dönüştürme çağrılır, türünden bir değer dönüştürür ***kaynak türünü***, başka bir türe adlı ***hedef türü***.</span><span class="sxs-lookup"><span data-stu-id="07320-438">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="07320-439">Kullanıcı tanımlı bir dönüştürmenin değerlendirme merkezi bulma ile ilgili ***en belirgin*** belirli kaynak ve hedef türleri için kullanıcı tanımlı dönüştürme işleci.</span><span class="sxs-lookup"><span data-stu-id="07320-439">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="07320-440">Bu belirleme, birkaç aşamaya ayrılır:</span><span class="sxs-lookup"><span data-stu-id="07320-440">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="07320-441">Sınıflar ve yapılar kullanıcı tanımlı dönüştürme işleçlerini kabul edilir kümesi bulunuyor.</span><span class="sxs-lookup"><span data-stu-id="07320-441">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="07320-442">Bu kaynak türü ve temel sınıflarının ve hedef türü ve kendi temel sınıflarla (kullanıcı tanımlı işleçler yalnızca sınıfları ve yapıları bildirebilir ve sınıf olmayan türler temel sınıfa sahip örtük varsayımların) oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-442">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="07320-443">Kaynak veya hedef türü ise bu adımı amaçları için bir *nullable_type*, kendi temel alınan türü kullanılan yerine.</span><span class="sxs-lookup"><span data-stu-id="07320-443">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="07320-444">Bu türleri kümesinden kullanıcı tanımlı ve dönüştürme işleçleri yükseltilmiş belirleme uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="07320-444">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="07320-445">Bir dönüştürme operatörünün uygulanabilmesi standart bir dönüştürme gerçekleştirmek mümkün olmalıdır ([standart dönüştürmeler](conversions.md#standard-conversions)) işlenenin kaynak türünden işleci ve standart bir dönüştürme gerçekleştirmek mümkün türünde olmalıdır Hedef türü işlecinin sonucu türünden.</span><span class="sxs-lookup"><span data-stu-id="07320-445">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="07320-446">Geçerli kullanıcı tanımlı işleçler kümesinden hangi işleci dönüştürmelerle en belirgin değil belirleme.</span><span class="sxs-lookup"><span data-stu-id="07320-446">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="07320-447">Genel koşullarını en belirgin işleci, işlenenin türü "kaynak türü için en yakın" ve "hedef türüne en yakın" sonuç türü olan işlecidir.</span><span class="sxs-lookup"><span data-stu-id="07320-447">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="07320-448">Kullanıcı tanımlı dönüştürme işleçleri yükseltilmiş dönüştürme işleçleri tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="07320-448">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="07320-449">Aşağıdaki bölümlerde en belirgin kullanıcı tanımlı dönüştürme işleci oluşturma tam kurallarını tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="07320-449">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="07320-450">En belirli bir kullanıcı tanımlı dönüştürme işleci belirlendikten sonra kullanıcı tanımlı dönüştürme gerçek yürütülmesi en çok üç adımdan oluşur:</span><span class="sxs-lookup"><span data-stu-id="07320-450">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="07320-451">İlk olarak, gerekli olursa yükseltilmiş veya kullanıcı tanımlı dönüştürme işleci işlenen türü kaynak türü bir standart dönüştürme gerçekleştirme.</span><span class="sxs-lookup"><span data-stu-id="07320-451">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="07320-452">Ardından, dönüştürmeyi gerçekleştirmek için yükseltilmiş veya kullanıcı tanımlı dönüştürme işleci çağrılıyor.</span><span class="sxs-lookup"><span data-stu-id="07320-452">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="07320-453">Son olarak, gerekli olursa yükseltilmiş veya kullanıcı tanımlı dönüştürme işleci sonuç türü hedef türüne standart dönüştürme gerçekleştirme.</span><span class="sxs-lookup"><span data-stu-id="07320-453">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="07320-454">Bir kullanıcı tanımlı dönüşümü hiçbir zaman birden fazla yükseltilmiş veya kullanıcı tanımlı dönüştürme işleci içeriyor.</span><span class="sxs-lookup"><span data-stu-id="07320-454">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="07320-455">Diğer bir deyişle, türünden dönüştürme `S` türüne `T` bir kullanıcı tanımlı dönüşümü hiçbir zaman önce yürütülür `S` için `X` ve kullanıcı tanımlı dönüştürme yürüten `X` için `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-455">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="07320-456">Kullanıcı tanımlı dönüştürme örtük veya açık değerlendirme tam tanımları aşağıdaki bölümlerde verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="07320-456">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="07320-457">Tanımları olun aşağıdaki koşulları kullanın:</span><span class="sxs-lookup"><span data-stu-id="07320-457">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="07320-458">Standart örtük bir dönüştürme ise ([standart örtük dönüştürmeler](conversions.md#standard-implicit-conversions)) bir türden var. `A` türüne `B`ve kullanılmazsa `A` ya da `B` olan *INTERFACE_TYPE*s, ardından `A` olduğu söylenir ***ile çevrelenmiş*** `B`, ve `B` edilir ***kapsayacak*** `A`.</span><span class="sxs-lookup"><span data-stu-id="07320-458">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="07320-459">***En kapsamlı türü*** türleri kümesi içinde kümedeki diğer tüm türleri kapsayan bir türdür.</span><span class="sxs-lookup"><span data-stu-id="07320-459">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="07320-460">Tek tür diğer tüm türleri kapsıyorsa, kümenin en kapsamlı tür yok.</span><span class="sxs-lookup"><span data-stu-id="07320-460">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="07320-461">En kapsamlı türü daha sezgisel bağlamında, "büyük" kümesindeki türüdür — istediğiniz diğer türlerinin her biri örtük olarak dönüştürülebilir bir tür.</span><span class="sxs-lookup"><span data-stu-id="07320-461">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="07320-462">***Türü'en çevrelenmiş*** türleri kümesi, kümedeki diğer tüm türleri ile çevrelenmiş bir türdür.</span><span class="sxs-lookup"><span data-stu-id="07320-462">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="07320-463">Ardından tek tür diğer türleri tarafından kapsadığı, küme türü çevrelenmiş Hayır en.</span><span class="sxs-lookup"><span data-stu-id="07320-463">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="07320-464">En encompassed türü daha sezgisel bağlamında, "küçük" kümesindeki türüdür; her diğer türleri için örtük olarak dönüştürülebilir bir tür.</span><span class="sxs-lookup"><span data-stu-id="07320-464">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="07320-465">İşlem kullanıcı tarafından tanımlanan örtük dönüştürme</span><span class="sxs-lookup"><span data-stu-id="07320-465">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="07320-466">Türünden kullanıcı tanımlı örtük dönüştürme `S` türüne `T` şu şekilde işlenir:</span><span class="sxs-lookup"><span data-stu-id="07320-466">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="07320-467">Türlerini belirleyin `S0` ve `T0`.</span><span class="sxs-lookup"><span data-stu-id="07320-467">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="07320-468">Varsa `S` veya `T` boş değer atanabilir türler `S0` ve `T0` Aksi takdirde, temel alınan türler olan `S0` ve `T0` eşit olan `S` ve `T` sırasıyla.</span><span class="sxs-lookup"><span data-stu-id="07320-468">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="07320-469">Bulma türleri, `D`, hangi kullanıcı tanımlı dönüştürme işleçlerini kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="07320-469">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="07320-470">Bu kümesi oluşur `S0` (varsa `S0` bir sınıf veya yapı), temel sınıflarını `S0` (varsa `S0` bir sınıf), ve `T0` (varsa `T0` bir sınıf veya yapı).</span><span class="sxs-lookup"><span data-stu-id="07320-470">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="07320-471">Geçerli kullanıcı tanımlı ve yükseltilmiş dönüştürme işleçleri kümesini bulmak `U`.</span><span class="sxs-lookup"><span data-stu-id="07320-471">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="07320-472">Bu sınıflar veya yapılar için tarafından bildirilen kullanıcı tanımlı ve yükseltilmiş örtük dönüşüm işleçleri oluşur `D` gelen bir kapsayan tür dönüştürme `S` ile çevrelenmiş bir türe `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-472">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="07320-473">Varsa `U` boş dönüştürme tanımlı değildir ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-473">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-474">En belirgin kaynak türü bulma `SX`, işleçler, `U`:</span><span class="sxs-lookup"><span data-stu-id="07320-474">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="07320-475">İşleçler, biri geçerliyse `U` dönüştürmek `S`, ardından `SX` olduğu `S`.</span><span class="sxs-lookup"><span data-stu-id="07320-475">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="07320-476">Aksi takdirde, `SX` en encompassed kaynak türleri, işleçler, birleştirilmiş bir dizi türünde `U`.</span><span class="sxs-lookup"><span data-stu-id="07320-476">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="07320-477">Tam olarak bir en çevrelenmiş tür bulunamıyor, sonra dönüştürme belirsiz değildir ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-477">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-478">En belirgin hedef türü, bulma `TX`, işleçler, `U`:</span><span class="sxs-lookup"><span data-stu-id="07320-478">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="07320-479">İşleçler, biri geçerliyse `U` Dönüştür `T`, ardından `TX` olduğu `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-479">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="07320-480">Aksi takdirde, `TX` en kapsamlı türü hedef türleri, işleçler, birleştirilmiş bir dizi içinde `U`.</span><span class="sxs-lookup"><span data-stu-id="07320-480">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="07320-481">En kapsamlı tam olarak bir tür dönüştürme belirsiz olduğu ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-481">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-482">En belirgin dönüştürme işleci bulun:</span><span class="sxs-lookup"><span data-stu-id="07320-482">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="07320-483">Varsa `U` dönüştürür tam olarak bir kullanıcı tanımlı dönüştürme işleci içeren `SX` için `TX`, bu ise en belirgin dönüştürme işleci.</span><span class="sxs-lookup"><span data-stu-id="07320-483">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="07320-484">Aksi takdirde `U` dönüştürür tam olarak bir yükseltilmiş dönüştürme işleci içeren `SX` için `TX`, bu ise en belirgin dönüştürme işleci.</span><span class="sxs-lookup"><span data-stu-id="07320-484">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="07320-485">Aksi takdirde, dönüştürme belirsiz değildir ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-485">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-486">Son olarak, bir dönüştürme uygulanır:</span><span class="sxs-lookup"><span data-stu-id="07320-486">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="07320-487">Varsa `S` değil `SX`, ardından standart örtük dönüştürme `S` için `SX` gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="07320-487">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="07320-488">En belirgin dönüştürme işleci dönüştürmek için çağrılan `SX` için `TX`.</span><span class="sxs-lookup"><span data-stu-id="07320-488">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="07320-489">Varsa `TX` değil `T`, ardından standart örtük dönüştürme `TX` için `T` gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="07320-489">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="07320-490">Kullanıcı tanımlı açık dönüştürmeler işlenmesini</span><span class="sxs-lookup"><span data-stu-id="07320-490">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="07320-491">Türünden kullanıcı tanımlı açık dönüştürme `S` türüne `T` şu şekilde işlenir:</span><span class="sxs-lookup"><span data-stu-id="07320-491">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="07320-492">Türlerini belirleyin `S0` ve `T0`.</span><span class="sxs-lookup"><span data-stu-id="07320-492">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="07320-493">Varsa `S` veya `T` boş değer atanabilir türler `S0` ve `T0` Aksi takdirde, temel alınan türler olan `S0` ve `T0` eşit olan `S` ve `T` sırasıyla.</span><span class="sxs-lookup"><span data-stu-id="07320-493">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="07320-494">Bulma türleri, `D`, hangi kullanıcı tanımlı dönüştürme işleçlerini kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="07320-494">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="07320-495">Bu kümesi oluşur `S0` (varsa `S0` bir sınıf veya yapı), temel sınıflarını `S0` (varsa `S0` bir sınıftır), `T0` (varsa `T0` bir sınıf veya yapı) ve temel sınıfları `T0` (varsa `T0`bir sınıfı).</span><span class="sxs-lookup"><span data-stu-id="07320-495">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="07320-496">Geçerli kullanıcı tanımlı ve yükseltilmiş dönüştürme işleçleri kümesini bulmak `U`.</span><span class="sxs-lookup"><span data-stu-id="07320-496">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="07320-497">Bu kullanıcı tarafından tanımlanan ve lifted örtük oluşur veya açık dönüştürme işleçleri bildirilen sınıflar veya yapılar için `D` gelen bir kapsayan tür dönüştürme veya ile çevrelenmiş `S` kapsayan veya ileçevrelenmişbirtürü`T`.</span><span class="sxs-lookup"><span data-stu-id="07320-497">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="07320-498">Varsa `U` boş dönüştürme tanımlı değildir ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-498">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-499">En belirgin kaynak türü bulma `SX`, işleçler, `U`:</span><span class="sxs-lookup"><span data-stu-id="07320-499">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="07320-500">İşleçler, biri geçerliyse `U` dönüştürmek `S`, ardından `SX` olduğu `S`.</span><span class="sxs-lookup"><span data-stu-id="07320-500">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="07320-501">Aksi durumda, işleçler, biri geçerliyse `U` kapsayacak türlerinden dönüştürme `S`, ardından `SX` kaynağı bu işleçleri tür birleşik kümesindeki en encompassed türüdür.</span><span class="sxs-lookup"><span data-stu-id="07320-501">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="07320-502">Çevrelenmiş hiçbir çoğu, türü bulunabilir, daha sonra dönüştürme belirsiz ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-502">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="07320-503">Aksi takdirde, `SX` en kapsamlı kaynak türleri, işleçler, birleştirilmiş bir dizi türünde `U`.</span><span class="sxs-lookup"><span data-stu-id="07320-503">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="07320-504">En kapsamlı tam olarak bir tür dönüştürme belirsiz olduğu ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-504">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-505">En belirgin hedef türü, bulma `TX`, işleçler, `U`:</span><span class="sxs-lookup"><span data-stu-id="07320-505">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="07320-506">İşleçler, biri geçerliyse `U` Dönüştür `T`, ardından `TX` olduğu `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-506">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="07320-507">Aksi durumda, işleçler, biri geçerliyse `U` tarafından çevrelenen türlere dönüştürmeniz `T`, ardından `TX` hedef türleri bu işleçleri birleştirilmiş bir dizi içinde en kapsamlı bir türdür.</span><span class="sxs-lookup"><span data-stu-id="07320-507">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="07320-508">En kapsamlı tam olarak bir tür dönüştürme belirsiz olduğu ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-508">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="07320-509">Aksi takdirde, `TX` en encompassed türü hedef türleri, işleçler, birleştirilmiş bir dizi içinde `U`.</span><span class="sxs-lookup"><span data-stu-id="07320-509">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="07320-510">Çevrelenmiş hiçbir çoğu, türü bulunabilir, daha sonra dönüştürme belirsiz ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-510">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-511">En belirgin dönüştürme işleci bulun:</span><span class="sxs-lookup"><span data-stu-id="07320-511">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="07320-512">Varsa `U` dönüştürür tam olarak bir kullanıcı tanımlı dönüştürme işleci içeren `SX` için `TX`, bu ise en belirgin dönüştürme işleci.</span><span class="sxs-lookup"><span data-stu-id="07320-512">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="07320-513">Aksi takdirde `U` dönüştürür tam olarak bir yükseltilmiş dönüştürme işleci içeren `SX` için `TX`, bu ise en belirgin dönüştürme işleci.</span><span class="sxs-lookup"><span data-stu-id="07320-513">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="07320-514">Aksi takdirde, dönüştürme belirsiz değildir ve bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-514">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-515">Son olarak, bir dönüştürme uygulanır:</span><span class="sxs-lookup"><span data-stu-id="07320-515">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="07320-516">Varsa `S` değil `SX`, ardından standart açık dönüştürme `S` için `SX` gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="07320-516">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="07320-517">En belirgin kullanıcı tanımlı dönüştürme işleci dönüştürmek için çağrılan `SX` için `TX`.</span><span class="sxs-lookup"><span data-stu-id="07320-517">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="07320-518">Varsa `TX` değil `T`, ardından standart açık dönüştürme `TX` için `T` gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="07320-518">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="07320-519">Anonim işlev dönüştürme</span><span class="sxs-lookup"><span data-stu-id="07320-519">Anonymous function conversions</span></span>

<span data-ttu-id="07320-520">Bir *anonymous_method_expression* veya *lambda_expression* anonim bir işlev sınıflandırılır ([anonim işlev ifadeleri](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="07320-520">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="07320-521">İfade, bir tür yoktur ama bir uyumlu temsilci türü ya da ifade ağaç türüne örtük olarak dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="07320-521">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="07320-522">Özellikle, anonim bir işlev `F` bir temsilci türüyle uyumlu `D` sağlanan:</span><span class="sxs-lookup"><span data-stu-id="07320-522">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="07320-523">Varsa `F` içeren bir *anonymous_function_signature*, ardından `D` ve `F` parametreleri aynı sayıda sahip.</span><span class="sxs-lookup"><span data-stu-id="07320-523">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="07320-524">Varsa `F` içermeyen bir *anonymous_function_signature*, ardından `D` hiçbir parametresi olarak uzun, her tür sıfır veya daha fazla parametrelere sahip `D` sahip `out` parametre değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="07320-524">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="07320-525">Varsa `F` her parametresinde bir açıkça belirtilmiş bir parametre listesine sahip `D` karşılık gelen parametre olarak aynı türde ve değiştiricilere sahip `F`.</span><span class="sxs-lookup"><span data-stu-id="07320-525">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="07320-526">Varsa `F` bir örtük olarak yazılan parametre listesine sahip `D` hiçbir `ref` veya `out` parametreleri.</span><span class="sxs-lookup"><span data-stu-id="07320-526">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="07320-527">Varsa gövdesinin `F` bir ifade ve ya da `D` sahip bir `void` dönüş türü veya `F` zaman uyumsuz olduğunu ve `D` dönüş türüne sahip `Task`, sonra ne zaman her parametresinin `F` türünü verilir karşılık gelen parametre `D`, gövdesi `F` geçerli bir ifade (wrt [ifadeleri](expressions.md)), izin olarak bir *statement_expression* ([İfade deyimleri](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="07320-527">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="07320-528">Varsa gövdesinin `F` bir deyim bloğunu ve ya da `D` sahip bir `void` dönüş türü veya `F` zaman uyumsuz olduğunu ve `D` dönüş türüne sahip `Task`, sonra ne zaman her parametresinin `F` türünü verilir karşılık gelen parametre `D`, gövdesi `F` geçerli deyim bloğu (wrt [blokları](statements.md#blocks)) hangi Hayır olarak `return` deyimi bir ifade belirtir.</span><span class="sxs-lookup"><span data-stu-id="07320-528">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="07320-529">Varsa gövdesinin `F` bir ifadedir ve *ya da* `F` olmayan zaman uyumsuz olduğunu ve `D` void olmayan dönüş türü olan `T`, *veya* `F` zaman uyumsuz olduğunu ve `D` dönüş türü olan `Task<T>`, sonra her parametresinin `F` karşılık gelen parametre türünü verilen `D`, gövdesi `F` geçerli bir ifade (wrt [ İfadeleri](expressions.md)), örtük olarak dönüştürülebilir `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-529">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="07320-530">Varsa gövdesinin `F` bir deyim bloğunu olduğu ve *ya da* `F` olmayan zaman uyumsuz olduğunu ve `D` void olmayan dönüş türü olan `T`, *veya* `F` zaman uyumsuz olduğunu ve `D` dönüş türü olan `Task<T>`, sonra her parametresinin `F` karşılık gelen parametre türünü verilen `D`, gövdesi `F` geçerli deyim bloğu (wrt [blokları ](statements.md#blocks)) her erişilebilir olmayan bir uç noktasıyla `return` ifadesi örtük olarak dönüştürülebilir bir ifade belirtir `T`.</span><span class="sxs-lookup"><span data-stu-id="07320-530">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="07320-531">Konuyu uzatmamak amacıyla, bu bölümde kısa formunu görev türleri için kullanılır. `Task` ve `Task<T>` ([zaman uyumsuz işlevleri](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="07320-531">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="07320-532">Bir lambda ifadesi `F` bir ifade ağacı türü ile uyumlu `Expression<D>` varsa `F` temsilci türüyle uyumlu `D`.</span><span class="sxs-lookup"><span data-stu-id="07320-532">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="07320-533">Bu anonim yöntem, lambda ifadeleri uygulanmaz unutmayın.</span><span class="sxs-lookup"><span data-stu-id="07320-533">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="07320-534">Belirli lambda ifadeleri ifade ağacı türlere dönüştürülemez: olsa bile dönüştürme *var.*, derleme zamanında başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="07320-534">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="07320-535">Bu büyük/küçük harf ise lambda ifadesi:</span><span class="sxs-lookup"><span data-stu-id="07320-535">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="07320-536">Sahip bir *blok* gövdesi</span><span class="sxs-lookup"><span data-stu-id="07320-536">Has a *block* body</span></span>
*  <span data-ttu-id="07320-537">Basit ve bileşik atama işleçleri içeriyor</span><span class="sxs-lookup"><span data-stu-id="07320-537">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="07320-538">Dinamik olarak bağlı bir ifade içeriyor</span><span class="sxs-lookup"><span data-stu-id="07320-538">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="07320-539">Zaman uyumsuz olduğu</span><span class="sxs-lookup"><span data-stu-id="07320-539">Is async</span></span>

<span data-ttu-id="07320-540">Genel temsilci türünde aşağıdaki örneklerde kullanın `Func<A,R>` türünde bir bağımsız değişken bir işlevi temsil eden `A` ve türünde bir değer döndürür `R`:</span><span class="sxs-lookup"><span data-stu-id="07320-540">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="07320-541">Atamaları</span><span class="sxs-lookup"><span data-stu-id="07320-541">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="07320-542">Her anonim işlev parametre ve dönüş türleri anonim işlev atanmış olduğu değişken türünden belirlenir.</span><span class="sxs-lookup"><span data-stu-id="07320-542">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="07320-543">İlk atama, anonim işlev başarıyla temsilci türüne dönüştürür. `Func<int,int>` olduğundan, `x` türü verilen `int`, `x+1` türüne örtük olarak dönüştürülebilir bir geçerli ifade `int`.</span><span class="sxs-lookup"><span data-stu-id="07320-543">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="07320-544">Benzer şekilde, ikinci atama başarıyla anonim işlev temsilci türüne dönüştürür `Func<int,double>` çünkü sonucunu `x+1` (tür `int`) türüne açıkça dönüştürülemez `double`.</span><span class="sxs-lookup"><span data-stu-id="07320-544">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="07320-545">Ancak, üçüncü bir derleme zamanı hatası nedeniyle atamadır, `x` türü verilen `double`, sonucunu `x+1` (tür `double`) türüne örtük olarak dönüştürülebilir değil `int`.</span><span class="sxs-lookup"><span data-stu-id="07320-545">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="07320-546">Dördüncü atama, anonim zaman uyumsuz işlev başarıyla temsilci türüne dönüştürür. `Func<int, Task<int>>` çünkü sonucunu `x+1` (tür `int`) sonuç türüne açıkça dönüştürülemez `int` görev türü `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="07320-546">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="07320-547">Anonim işlevler aşırı yükleme çözünürlüğü etkiler ve içinde tür çıkarımı katılın.</span><span class="sxs-lookup"><span data-stu-id="07320-547">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="07320-548">Bkz: [işlev üyeleri](expressions.md#function-members) daha ayrıntılı bilgi için.</span><span class="sxs-lookup"><span data-stu-id="07320-548">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="07320-549">Değerlendirme temsilci türleri olarak anonim işlev dönüştürme</span><span class="sxs-lookup"><span data-stu-id="07320-549">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="07320-550">Anonim bir işlevin bir temsilci türüne dönüştürme anonim işlev ve değerlendirme sırasındaki etkin olan dış yakalanan değişkenlere (büyük olasılıkla boş) kümesini başvuran bir temsilci örneği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="07320-550">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="07320-551">Temsilci çağrıldığında, anonim işlev gövdesi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-551">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="07320-552">Temsilci tarafından başvurulan yakalanan dış değişkenler kümesini kullanarak gövdesindeki kod yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-552">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="07320-553">Anonim bir işlevden üretilen bir temsilcinin çağırma listesi tek bir giriş içerir.</span><span class="sxs-lookup"><span data-stu-id="07320-553">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="07320-554">Hedef yöntemin temsilcisi ve tam hedef nesne belirtilmemiş.</span><span class="sxs-lookup"><span data-stu-id="07320-554">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="07320-555">Özellikle, bu temsilci hedef nesneye olup belirtilmezse `null`, `this` kapsayan işlev üyesi veya başka bir nesnenin değeri.</span><span class="sxs-lookup"><span data-stu-id="07320-555">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="07320-556">Anlamsal olarak eşdeğer anonim işlevleri aynı temsilci türleri için dönüştürme yakalanan dış değişken örnekleri aynı (büyük olasılıkla boş) kümesi ile izin verilir (ancak gerekli değildir) aynı temsilci örneği dönün.</span><span class="sxs-lookup"><span data-stu-id="07320-556">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="07320-557">Anlamsal olarak eşdeğer terimi, burada anonim işlevler yürütülmesini her durumda, aynı bağımsız değişkenleri verilen aynı etkileri üreteceği ifade etmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="07320-557">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="07320-558">Bu kural, en iyi duruma getirilmesi aşağıdaki gibi bir kod izin verir.</span><span class="sxs-lookup"><span data-stu-id="07320-558">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="07320-559">İki anonim işlev temsilcileri aynı (boş) yakalanan dış değişkenlerin ve anonim işlevler anlamsal olarak aynı olduğundan olduğundan, derleyici başvurmak için aynı hedef yöntemin temsilcilerin izin verilir.</span><span class="sxs-lookup"><span data-stu-id="07320-559">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="07320-560">Aslında, derleyici hem anonim işlev ifadeleri çok aynı temsilci örneği döndürmek için izin verilir.</span><span class="sxs-lookup"><span data-stu-id="07320-560">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="07320-561">İfade ağacı türlerine dönüştürme işlemi anonim İşlev değerlendirmesi</span><span class="sxs-lookup"><span data-stu-id="07320-561">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="07320-562">İfade ağacı anonim bir işlevin bir ifade ağacı türü dönüştürme üretir ([ifade ağacı türleri](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="07320-562">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="07320-563">Anonim işlev yapısını temsil eden bir nesne yapısını oluşumu için daha kesin bir şekilde değerlendirme anonim işlev dönüştürme yol açar.</span><span class="sxs-lookup"><span data-stu-id="07320-563">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="07320-564">Uygulama tanımlı kesin yapısını ifade ağacı yanı sıra, tam, oluşturma işlemi var.</span><span class="sxs-lookup"><span data-stu-id="07320-564">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="07320-565">Uygulama örneği</span><span class="sxs-lookup"><span data-stu-id="07320-565">Implementation example</span></span>

<span data-ttu-id="07320-566">Bu bölümde, anonim işlev dönüştürmeler diğer C# yapılarını açısından olası bir uygulaması açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="07320-566">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="07320-567">Burada açıklanan uygulama Microsoft C# derleyicisi tarafından kullanılan aynı ilkeler temel alır, ancak göre Hayır olmadığı bir mandated uygulamasıdır veya yalnızca bir mümkün değil.</span><span class="sxs-lookup"><span data-stu-id="07320-567">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="07320-568">Bu belirtim kapsamı dışında tam semantiği olduğu gibi yalnızca kısa bir süreliğine ifade ağaçlarında yapılan dönüştürmeler bahseder.</span><span class="sxs-lookup"><span data-stu-id="07320-568">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="07320-569">Bu bölümün geri kalanında, çeşitli farklı özelliklere sahip anonim işlevler içeren kod örneklerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="07320-569">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="07320-570">Her örnek için yalnızca diğer C# yapılarını kullanan kod için karşılık gelen bir çeviri sağlanır.</span><span class="sxs-lookup"><span data-stu-id="07320-570">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="07320-571">Örneklerde, tanımlayıcı `D` aşağıdaki temsilci türünü temsil tarafından kabul edilir:</span><span class="sxs-lookup"><span data-stu-id="07320-571">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="07320-572">Anonim bir işlevdir en basit biçimi dış değişken yakalayan biridir:</span><span class="sxs-lookup"><span data-stu-id="07320-572">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="07320-573">Bu, anonim işlev kodunu yerleştirildiği bir derleyicinin ürettiği statik bir yönteme başvuran bir temsilci örneklemesine çevrilebilir:</span><span class="sxs-lookup"><span data-stu-id="07320-573">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="07320-574">Aşağıdaki örnekte, örnek üyeleri anonim işlev başvuruyor `this`:</span><span class="sxs-lookup"><span data-stu-id="07320-574">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="07320-575">Bu, derleyicinin ürettiği örnek yöntemine anonim işlev kodunu içeren bir çevrilebilir:</span><span class="sxs-lookup"><span data-stu-id="07320-575">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="07320-576">Bu örnekte, anonim işlev bir yerel değişken yakalar:</span><span class="sxs-lookup"><span data-stu-id="07320-576">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="07320-577">Yerel değişken ömrü artık en az anonim işlev temsilcisi ömrünü genişletilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="07320-577">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="07320-578">Bu, "yerel değişken bir derleyicinin ürettiği sınıfının bir alanı hoisting tarafından" gerçekleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="07320-578">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="07320-579">Yerel değişken örneğinin ([yerel değişkenler örneğinin](expressions.md#instantiation-of-local-variables)) derleyicinin ürettiği sınıfı ve yerel değişken karşılık gelen örneğini bir alana erişimi erişen bir örneğini oluşturmak için'karşılık gelir Derleyicinin ürettiği sınıfı.</span><span class="sxs-lookup"><span data-stu-id="07320-579">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="07320-580">Ayrıca, derleyicinin ürettiği sınıfının bir örneği yöntemi anonim işlev olur:</span><span class="sxs-lookup"><span data-stu-id="07320-580">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="07320-581">Son olarak, aşağıdaki anonim yakalamaları işlev `this` iki yerel değişkenler farklı ömürleriyle yanı sıra:</span><span class="sxs-lookup"><span data-stu-id="07320-581">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="07320-582">Burada, derleyicinin ürettiği sınıfı for each deyimi oluşturulur hangi Yereller yakalanan farklı bloklar yerel öğeler, bağımsız yaşam süreleri olabilir, içinde engelleyin.</span><span class="sxs-lookup"><span data-stu-id="07320-582">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="07320-583">Örneği `__Locals2`, iç deyim bloğu için derleyicinin ürettiği sınıfı içeren yerel değişken `z` örneği başvuran bir alan `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="07320-583">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="07320-584">Örneği `__Locals1`, derleyicinin ürettiği sınıfı için dış bir deyim bloğunu içeren yerel değişken `y` ve başvuran bir alan `this` kapsayan işlevi üyesinin.</span><span class="sxs-lookup"><span data-stu-id="07320-584">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="07320-585">Bu veri yapıları ulaşmak mümkün olduğu bir örneği üzerinden dış değişkenlere yakalanan `__Local2`, ve anonim işlev kodunu böylece söz konusu sınıfın bir örnek yöntemi olarak uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="07320-585">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="07320-586">Burada yerel değişkenler yakalamak için uygulanan aynı tekniği de anonim işlevler için ifade ağaçları dönüştürülürken kullanılabilir: derleyicinin ürettiği nesnelere başvuru ifade ağacında depolanabilir ve yerel değişkenlere erişimi olabilir. Bu nesneler üzerinde alan erişen olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="07320-586">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="07320-587">Bu yaklaşımın avantajı, temsilciler ve ifade ağaçları arasında paylaşılmak üzere "lifted" yerel değişkenler olanak sağlamasıdır.</span><span class="sxs-lookup"><span data-stu-id="07320-587">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="07320-588">Yöntem grubu dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="07320-588">Method group conversions</span></span>

<span data-ttu-id="07320-589">Örtük bir dönüştürme ([örtük dönüştürmelerin](conversions.md#implicit-conversions)) bir yöntem grubu var ([ifade sınıflandırmaları](expressions.md#expression-classifications)) uyumlu temsilci türü.</span><span class="sxs-lookup"><span data-stu-id="07320-589">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="07320-590">Bir temsilci türü verilen `D` ve ifade `E` öğesinden örtük bir dönüştürme var, bir yöntem grubu sınıflandırılan `E` için `D` varsa `E` içinde normal bir form (geçerli olan en az bir yöntem içerir [Geçerli işlev üyesi](expressions.md#applicable-function-member)) için bir bağımsız değişken listesi parametre türlerinin kullanımı ve öğesinin değiştiricilerini tarafından oluşturulan `D`aşağıda açıklandığı gibi.</span><span class="sxs-lookup"><span data-stu-id="07320-590">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="07320-591">Bir yöntem grubu dönüştürme derleme zamanı uygulamasının `E` temsilci türüne `D` aşağıda açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="07320-591">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="07320-592">Unutmayın örtük bir dönüştürme varlığını `E` için `D` dönüştürme derleme zamanı uygulamasının hata başarılı olduğunu garanti etmez.</span><span class="sxs-lookup"><span data-stu-id="07320-592">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="07320-593">Tek bir yöntem `M` bir yöntem çağırma için karşılık gelen seçili ([yöntem çağrıları](expressions.md#method-invocations)) biçiminde `E(A)`, aşağıdaki değişiklikler ile:</span><span class="sxs-lookup"><span data-stu-id="07320-593">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="07320-594">Bağımsız değişken listesi `A` ifadeleri, bir değişken olarak ve tür ve değiştiricisi ile her sınıflandırılmış bir listesi verilmiştir (`ref` veya `out`) karşılık gelen parametre, *formal_parameter_list* ,`D`.</span><span class="sxs-lookup"><span data-stu-id="07320-594">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="07320-595">Normal formlarına için geçerli olan yöntemlerden kabul aday yöntemler şunlardır ([geçerli işlev üyesi](expressions.md#applicable-function-member)), olanları yalnızca kendi genişletilmiş biçimde uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="07320-595">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="07320-596">Varsa algoritmasının [yöntem çağrıları](expressions.md#method-invocations) bir derleme zamanı hatası oluşursa bir hata üretir.</span><span class="sxs-lookup"><span data-stu-id="07320-596">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="07320-597">Aksi takdirde algoritma tek bir en iyi yöntem üretir `M` aynı sayıda parametrelere sahip `D` ve dönüştürme yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="07320-597">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="07320-598">Seçilen yöntemi `M` uyumlu olması gerekir ([temsilci Uyumluluk](delegates.md#delegate-compatibility)) temsilci türüyle `D`, veya aksi halde, bir derleme zamanı hatası oluşur.</span><span class="sxs-lookup"><span data-stu-id="07320-598">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="07320-599">Seçilen yöntemi `M` örnek ifade ile ilişkili bir örnek yöntemi olduğundan `E` hedef nesneye temsilci belirler.</span><span class="sxs-lookup"><span data-stu-id="07320-599">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="07320-600">Seçili yöntem M örnek bir ifade üzerinde bir üye erişimi ile belirtilir bir genişletme yöntemi ise, hedef nesneye temsilci örneği ifade belirler.</span><span class="sxs-lookup"><span data-stu-id="07320-600">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="07320-601">Dönüştürme sonucu olarak bir tür değeri `D`, yani seçili yöntemi ve hedef nesneye başvuran bir yeni oluşturulan temsilci.</span><span class="sxs-lookup"><span data-stu-id="07320-601">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="07320-602">Bu işlem bir genişletme yöntemi için bir temsilci oluşturulmasına yol açabilir Not algoritmasının [yöntem çağrıları](expressions.md#method-invocations) bir örnek yöntemi bulmada başarısız ancak çağırmayı işlenirken başarılı `E(A)` bir uzantısı olarak yöntem çağırma ([uzantısı yöntem çağrıları](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="07320-602">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="07320-603">Bu nedenle oluşturulan bir temsilci, genişletme yönteminin yanı sıra, ilk bağımsız değişkeninin yakalar.</span><span class="sxs-lookup"><span data-stu-id="07320-603">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="07320-604">Aşağıdaki örnekte, yöntem grubu dönüştürmeler göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="07320-604">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="07320-605">Atamayı `d1` örtük olarak yöntem grubu dönüştürür `F` türünde bir değer için `D1`.</span><span class="sxs-lookup"><span data-stu-id="07320-605">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="07320-606">Atamayı `d2` nasıl daha az türetilmiş (değişken karşıtı) parametre türleri içeren bir yöntem için temsilci oluşturmak mümkündür ve daha türetilmiş (değişken) dönüş türü gösterir.</span><span class="sxs-lookup"><span data-stu-id="07320-606">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="07320-607">Atamayı `d3` nasıl dönüştürme var yöntemi uygulanabilir değilse gösterir.</span><span class="sxs-lookup"><span data-stu-id="07320-607">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="07320-608">Atamayı `d4` nasıl yöntemi, normal bir biçimde uygun olmalıdır gösterir.</span><span class="sxs-lookup"><span data-stu-id="07320-608">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="07320-609">Atamayı `d5` parametre ve dönüş türlerinin ve temsilci yöntemi yalnızca başvuru türleri için farklı nasıl verildiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="07320-609">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="07320-610">İle tüm diğer örtük ve açık dönüştürmeler gibi atama işleci açıkça bir yöntem grubu dönüştürme gerçekleştirmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="07320-610">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="07320-611">Bu nedenle, örneğin</span><span class="sxs-lookup"><span data-stu-id="07320-611">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="07320-612">Bunun yerine yazılabilir</span><span class="sxs-lookup"><span data-stu-id="07320-612">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="07320-613">Yöntemi gruplarına aşırı yükleme çözünürlüğü etkilemek ve içinde tür çıkarımı katılın.</span><span class="sxs-lookup"><span data-stu-id="07320-613">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="07320-614">Bkz: [işlev üyeleri](expressions.md#function-members) daha ayrıntılı bilgi için.</span><span class="sxs-lookup"><span data-stu-id="07320-614">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="07320-615">Bir yöntem grubu dönüştürmenin çalışma zamanı değerlendirme gibi çalışır:</span><span class="sxs-lookup"><span data-stu-id="07320-615">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="07320-616">Derleme zamanında seçilen yöntemi bir örnek yöntemi olduğundan veya bir örnek yöntemi erişilebilen bir genişletme yöntemi, temsilci hedef nesnesi ile ilişkili örneği ifadesinden belirlenir `E`:</span><span class="sxs-lookup"><span data-stu-id="07320-616">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="07320-617">Örnek ifade değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="07320-617">The instance expression is evaluated.</span></span> <span data-ttu-id="07320-618">Bu değerlendirme bir özel durum neden olursa, başka bir adım yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-618">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="07320-619">Örnek ifade ise bir *reference_type*, örnek ifade tarafından hesaplanan değer hedef nesne haline gelir.</span><span class="sxs-lookup"><span data-stu-id="07320-619">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="07320-620">Seçilen yöntemi bir örnek yöntemi olduğundan ve hedef nesnesi `null`, `System.NullReferenceException` oluşturulur ve başka bir adım yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-620">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="07320-621">Örnek ifade ise bir *value_type*, bir paketleme işlemi ([kutulama dönüştürmeler](types.md#boxing-conversions)) değeri bir nesneye dönüştürmek için gerçekleştirilir ve bu nesne, hedef nesne haline gelir.</span><span class="sxs-lookup"><span data-stu-id="07320-621">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="07320-622">Aksi takdirde seçilen yöntemi statik yöntem çağrısı bir parçasıdır ve temsilcinin hedef nesnesi `null`.</span><span class="sxs-lookup"><span data-stu-id="07320-622">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="07320-623">Temsilci türüne yeni bir örneğini `D` ayrılır.</span><span class="sxs-lookup"><span data-stu-id="07320-623">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="07320-624">Yeni bir örneğini ayırmak yeterli bellek yoksa bir `System.OutOfMemoryException` oluşturulur ve başka bir adım yürütülür.</span><span class="sxs-lookup"><span data-stu-id="07320-624">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="07320-625">Derleme zamanında belirlenen bir yönteme başvuru ile yeni temsilci örneği başlatılır ve hedef nesneye bir başvuru üzerinde hesaplanan.</span><span class="sxs-lookup"><span data-stu-id="07320-625">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
